{
  "model": "gemini",
  "functions": [
    {
      "name": "monitors_health_get",
      "parameters": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "description": "Health check API."
    },
    {
      "name": "monitors_performance_get",
      "parameters": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "description": "Get performance information.\n\nGet perofmration information composed with CPU, memory and resource usage."
    },
    {
      "name": "shoppings_admins_coupons_erase",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target coupon's {@link IShoppingCoupon.id }"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Erase a coupon.\n\nErase a {@link IShoppingCoupon coupon} with given ID.\n\nFor reference, if there're some {@link IShoppingCouponTicket tickets}\nwhich are already issued from the target coupon, they would not be affected.\nThose tickets are still valid until their expration time."
    },
    {
      "name": "shoppings_admins_deposits_create",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "code": {
                "type": "string"
              },
              "source": {
                "type": "string"
              },
              "direction": {
                "type": "number",
                "enum": [
                  -1,
                  1
                ]
              }
            },
            "required": [
              "code",
              "source",
              "direction"
            ],
            "description": "Creation information of deposit metadata\n\n------------------------------\n\nCurrent Type: {@link IShoppingDeposit.ICreate}"
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "Create a new deposit metadata.\n\nCreate a new {@link IShoppingDeposit deposit} metadata.\n\nThis action means that adding a new origin reason of deposit's income/outcome.\nOf course, creating a new deposit record does not mean that automatically\nincrease or decrease the {@link IShoppingCustomer customer}'s balance\nfollowing the record's reason why. The logic must be developed manually\nin the backend side."
    },
    {
      "name": "shoppings_admins_deposits_index",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "search": {
                "type": "object",
                "properties": {
                  "source": {
                    "type": "string",
                    "nullable": true
                  },
                  "code": {
                    "type": "string",
                    "nullable": true
                  },
                  "direction": {
                    "type": "number",
                    "enum": [
                      -1,
                      1
                    ],
                    "nullable": true
                  }
                },
                "required": [],
                "nullable": true
              },
              "sort": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "-deposit.source",
                    "-deposit.code",
                    "-deposit.direction",
                    "+deposit.source",
                    "+deposit.code",
                    "+deposit.direction"
                  ]
                },
                "nullable": true
              },
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Request info of pagination, searching and sorting\n\n------------------------------\n\nCurrent Type: {@link IShoppingDeposit.IRequest}"
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "Get deposit metadata list.\n\nList up every {@link IShoppingDeposit deposit} metadata information\nwith {@link IPage pagination}.\n\nIf you want, you can limit the result by configuring\n{@link IShoppingDeposit.IRequest.search search condition} in the request body.\nAlso, it is possible to customize sequence order of records by configuring\n{@link IShoppingDeposit.IRequest.sort sort condition}."
    },
    {
      "name": "shoppings_admins_deposits_at",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target deposit's {@link IShoppingDeposit.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Get a deposit metadata.\n\nGet a {@link IShoppingDeposit deposit} metadata information with its ID."
    },
    {
      "name": "shoppings_admins_deposits_erase",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target deposit's {@link IShoppingDeposit.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Erase a deposit metadata.\n\nErase a {@link IShoppingDeposit deposit} metadata, so that no more\n{@link IShoppingCustomer customer}'s balance does not be increased or\ndecreased by the deposit's reason why."
    },
    {
      "name": "shoppings_admins_deposits_get",
      "parameters": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string"
          }
        },
        "required": [
          "code"
        ]
      },
      "description": "Get a deposit metadata by its code.\n\nGet a {@link IShoppingDeposit deposit} metadata information with its code."
    },
    {
      "name": "shoppings_admins_mileages_create",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "code": {
                "type": "string"
              },
              "source": {
                "type": "string"
              },
              "direction": {
                "type": "number",
                "enum": [
                  -1,
                  1
                ]
              },
              "value": {
                "type": "number",
                "nullable": true
              }
            },
            "required": [
              "code",
              "source",
              "direction",
              "value"
            ],
            "description": "Creation information of mileage metadata\n\n------------------------------\n\nCurrent Type: {@link IShoppingMileage.ICreate}"
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "Create a new mileage metadata.\n\nCreate a new {@link IShoppingMileage mileage} metadata.\n\nThis action means that adding a new origin reason of mileage's income/outcome.\nOf course, creating a new mileage record does not mean that automatically\nincrease or decrease the {@link IShoppingCustomer customer}'s balance\nfollowing the record's reason why. The logic must be developed manually\nin the backend side."
    },
    {
      "name": "shoppings_admins_mileages_index",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "search": {
                "type": "object",
                "properties": {
                  "source": {
                    "type": "string",
                    "nullable": true
                  },
                  "code": {
                    "type": "string",
                    "nullable": true
                  },
                  "direction": {
                    "type": "number",
                    "enum": [
                      -1,
                      1
                    ],
                    "nullable": true
                  }
                },
                "required": [],
                "nullable": true
              },
              "sort": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "-mileage.source",
                    "-mileage.code",
                    "-mileage.direction",
                    "+mileage.source",
                    "+mileage.code",
                    "+mileage.direction"
                  ]
                },
                "nullable": true
              },
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Request info of pagination, searching and sorting\n\n------------------------------\n\nCurrent Type: {@link IShoppingMileage.IRequest}"
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "Get mileage metadata list.\n\nList up every {@link IShoppingMileage mileage} metadata information\nwith {@link IPage pagination}.\n\nIf you want, you can limit the result by configuring\n{@link IShoppingMileage.IRequest.search search condition} in the request body.\nAlso, it is possible to customize sequence order of records by configuring\n{@link IShoppingMileage.IRequest.sort sort condition}."
    },
    {
      "name": "shoppings_admins_mileages_at",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target mileage's {@link IShoppingMileage.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Get a mileage metadata.\n\nGet a {@link IShoppingMileage mileage} metadata information with its ID."
    },
    {
      "name": "shoppings_admins_mileages_erase",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target mileage's {@link IShoppingMileage.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Erase a mileage metadata.\n\nErase a {@link IShoppingMileage mileage} metadata, so that no more\n{@link IShoppingCustomer customer}'s balance does not be increased or\ndecreased by the mileage's reason why."
    },
    {
      "name": "shoppings_admins_mileages_get",
      "parameters": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string"
          }
        },
        "required": [
          "code"
        ]
      },
      "description": "Get a mileage metadata by its code.\n\nGet a {@link IShoppingMileage mileage} metadata information with its code."
    },
    {
      "name": "shoppings_admins_sales_index",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "sort": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "-seller.created_at",
                    "-seller.goods.payments.real",
                    "-seller.goods.publish_count",
                    "-seller.reviews.average",
                    "-seller.reviews.count",
                    "-goods.publish_count",
                    "-goods.payments.real",
                    "-reviews.average",
                    "-reviews.count",
                    "-sale.created_at",
                    "-sale.updated_at",
                    "-sale.opened_at",
                    "-sale.closed_at",
                    "-sale.content.title",
                    "-sale.price_range.lowest.real",
                    "-sale.price_range.highest.real",
                    "+seller.created_at",
                    "+seller.goods.payments.real",
                    "+seller.goods.publish_count",
                    "+seller.reviews.average",
                    "+seller.reviews.count",
                    "+goods.publish_count",
                    "+goods.payments.real",
                    "+reviews.average",
                    "+reviews.count",
                    "+sale.created_at",
                    "+sale.updated_at",
                    "+sale.opened_at",
                    "+sale.closed_at",
                    "+sale.content.title",
                    "+sale.price_range.lowest.real",
                    "+sale.price_range.highest.real"
                  ]
                },
                "nullable": true,
                "description": "Sorting conditions."
              },
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Request info of pagination, searching and sorting\n\n------------------------------\n\nDescription of the current {@link IShoppingSale.IRequest} type:\n\n> Request of summarized sales with pagination and searching/sorting options.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSale} type:\n\n> Seller sales products.\n> \n> `IShoppingSale` is an entity that embodies \"product sales\" (sales)\n> information registered by the {@link ISoppingSeller seller}. And the main\n> information of the sale is recorded in the sub {@link IShoppingSaleSnapshot},\n> not in the main `IShoppingSale`. When a seller changes a previously registered\n> item, the existing `IShoppingSale` record is not changed, but a new\n> {@link IShoppingSaleSnapshot snapshot} record be created.\n> \n> This is to preserve the {@link IShoppingCustomer customer}'s\n> {@link IShoppingOrder purchase history} flawlessly after the customer\n> purchases a specific item, even if the seller changes the components or\n> price of the item. It is also intended to support sellers in so-called A/B\n> testing, which involves changing components or prices and measuring the\n> performance in each case."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "List up every summarized sales.\n\nList up every {@link IShoppingSale.ISummary summarized sales}.\n\nAs you can see, returned sales are summarized, not detailed. It does not\ncontain the SKU (Stock Keeping Unit) information represented by the\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\nIf you want to get such detailed information of a sale, use\n`GET /shoppings/customers/sales/{id}` operation for each sale.\n\n> If you're an A.I. chatbot, and the user wants to buy or compose\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\n> to the target sale to get detailed SKU information about the sale.\n> It needs to be run at least once for the next steps."
    },
    {
      "name": "shoppings_admins_sales_questions_comments_update",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Belonged sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "inquiryId": {
            "type": "string",
            "description": " Belonged inquiry's {@link IShoppingSaleInquiry.id }\n\n\n@format uuid"
          },
          "id": {
            "type": "string",
            "description": " Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "format": {
                "type": "string",
                "enum": [
                  "html",
                  "md",
                  "txt"
                ],
                "description": "Format of body.\n\nSame meaning with extension like `html`, `md`, `txt`."
              },
              "body": {
                "type": "string",
                "description": "Content body of comment."
              },
              "files": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "File name, except extension.\n\nIf there's file `.gitignore`, then its name is an empty string.\n\n\n@maxLength 255"
                    },
                    "extension": {
                      "type": "string",
                      "nullable": true,
                      "description": "Extension.\n\nPossible to omit like `README` case.\n\n\n@minLength 1\n@maxLength 8"
                    },
                    "url": {
                      "type": "string",
                      "description": "URL path of the real file.\n\n\n@format uri\n@contentMediaType image/*"
                    }
                  },
                  "required": [
                    "name",
                    "extension",
                    "url"
                  ],
                  "description": "Current Type: {@link IAttachmentFile.ICreate}\n\n------------------------------\n\nDescription of the parent {@link IAttachmentFile} type:\n\n> Attachment File.\n> \n> Every attachment files that are managed in current system.\n> \n> For reference, it is possible to omit one of file {@link name}\n> or {@link extension} like `.gitignore` or `README` case, but not\n> possible to omit both of them."
                },
                "description": "List of attachment files."
              }
            },
            "required": [
              "format",
              "body",
              "files"
            ],
            "description": "Update info of the inquiry comment\n\n------------------------------\n\nDescription of the current {@link IShoppingSaleInquiryComment.ICreate} type:\n\n> Creation information of the comment.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSaleInquiryComment} type:\n\n> A comment written on an inquiry article.\n> \n> `IShoppingSaleInquiryComment` is a subtype entity of {@link IBbsArticleComment},\n> and is used when you want to communicate with multiple people about an\n> {@link IShoppingSaleInquiry inquiry} written by a\n> {@link IShoppingCustomer customer}.\n> \n> For reference, only related parties can write comments for\n> {@link IShoppingSeller sellers}, but there is no limit to\n> {@link IShoppingCustomer customers}. In other words, anyone customer can\n> freely write a comment, even if they are not the person who wrote the inquiry."
          }
        },
        "required": [
          "saleId",
          "inquiryId",
          "id",
          "body"
        ]
      },
      "description": "Update an inquiry comment.\n\nUpdate an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n\nBy the way, as is the general policy of this shopping mall regarding\ncomments, modifying a comment does not actually change the existing content.\nModified content is accumulated and recorded in the existing comment record\nas a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this\nis made public to everyone, who can read this inquiry comment.\n\nThis is to prevent customers or sellers from modifying their comments and\nmanipulating the circumstances due to the nature of e-commerce, where\ndisputes easily arise. That is, to preserve evidence."
    },
    {
      "name": "shoppings_admins_sales_reviews_comments_update",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Belonged sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "inquiryId": {
            "type": "string",
            "description": " Belonged inquiry's {@link IShoppingSaleInquiry.id }\n\n\n@format uuid"
          },
          "id": {
            "type": "string",
            "description": " Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "format": {
                "type": "string",
                "enum": [
                  "html",
                  "md",
                  "txt"
                ],
                "description": "Format of body.\n\nSame meaning with extension like `html`, `md`, `txt`."
              },
              "body": {
                "type": "string",
                "description": "Content body of comment."
              },
              "files": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "File name, except extension.\n\nIf there's file `.gitignore`, then its name is an empty string.\n\n\n@maxLength 255"
                    },
                    "extension": {
                      "type": "string",
                      "nullable": true,
                      "description": "Extension.\n\nPossible to omit like `README` case.\n\n\n@minLength 1\n@maxLength 8"
                    },
                    "url": {
                      "type": "string",
                      "description": "URL path of the real file.\n\n\n@format uri\n@contentMediaType image/*"
                    }
                  },
                  "required": [
                    "name",
                    "extension",
                    "url"
                  ],
                  "description": "Current Type: {@link IAttachmentFile.ICreate}\n\n------------------------------\n\nDescription of the parent {@link IAttachmentFile} type:\n\n> Attachment File.\n> \n> Every attachment files that are managed in current system.\n> \n> For reference, it is possible to omit one of file {@link name}\n> or {@link extension} like `.gitignore` or `README` case, but not\n> possible to omit both of them."
                },
                "description": "List of attachment files."
              }
            },
            "required": [
              "format",
              "body",
              "files"
            ],
            "description": "Update info of the inquiry comment\n\n------------------------------\n\nDescription of the current {@link IShoppingSaleInquiryComment.ICreate} type:\n\n> Creation information of the comment.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSaleInquiryComment} type:\n\n> A comment written on an inquiry article.\n> \n> `IShoppingSaleInquiryComment` is a subtype entity of {@link IBbsArticleComment},\n> and is used when you want to communicate with multiple people about an\n> {@link IShoppingSaleInquiry inquiry} written by a\n> {@link IShoppingCustomer customer}.\n> \n> For reference, only related parties can write comments for\n> {@link IShoppingSeller sellers}, but there is no limit to\n> {@link IShoppingCustomer customers}. In other words, anyone customer can\n> freely write a comment, even if they are not the person who wrote the inquiry."
          }
        },
        "required": [
          "saleId",
          "inquiryId",
          "id",
          "body"
        ]
      },
      "description": "Update an inquiry comment.\n\nUpdate an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n\nBy the way, as is the general policy of this shopping mall regarding\ncomments, modifying a comment does not actually change the existing content.\nModified content is accumulated and recorded in the existing comment record\nas a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this\nis made public to everyone, who can read this inquiry comment.\n\nThis is to prevent customers or sellers from modifying their comments and\nmanipulating the circumstances due to the nature of e-commerce, where\ndisputes easily arise. That is, to preserve evidence."
    },
    {
      "name": "shoppings_admins_sales_snapshots_index",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Target sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Requestion info of pagination\n\n------------------------------\n\nDescription of the current {@link IPage.IRequest} type:\n\n> Page request data"
          }
        },
        "required": [
          "saleId",
          "body"
        ]
      },
      "description": "List up every snapshots.\n\nWhenever {@link IShoppingSeller seller} updates a\n{@link IShoppingSale sale}, the sale record is not updated but a new\n{@link IShoppingSaleSnapshot snapshot} record is created to keep the\nintegrity of the sale history. This API function is for listing up\nsuch snapshot records.\n\nAlso, as you can see from the return type, returned snapshots are\nsummarized, not detailed. If you want to get the detailed information\nof a snapshot, use {@link at} or {@link flipo} function for each snapshot.\n\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\naccess to the your own {@link IShoppingSale sale}'s snapshots. Otherwise,\nyou can access to every snapshots of the sales even though the sale has\nbeen closed or suspended."
    },
    {
      "name": "shoppings_admins_systematic_channels_categories_create",
      "parameters": {
        "type": "object",
        "properties": {
          "channelCode": {
            "type": "string",
            "description": " Belonged channel's {@link IShoppingChannel.code }"
          },
          "body": {
            "type": "object",
            "properties": {
              "parent_id": {
                "type": "string",
                "nullable": true,
                "description": "Parent category's ID.\n\n\n@format uuid"
              },
              "code": {
                "type": "string",
                "description": "Identifier code of the category.\n\nThe code must be unique in the channel."
              },
              "name": {
                "type": "string",
                "description": "Representative name of the category.\n\nThe name must be unique within the parent category. If no parent exists,\nthen the name must be unique within the channel between no parent\ncategories."
              }
            },
            "required": [
              "parent_id",
              "code",
              "name"
            ],
            "description": "Creation info of the category\n\n------------------------------\n\nDescription of the current {@link IShoppingChannelCategory.ICreate} type:\n\n> Creation information of the category.\n\n------------------------------\n\nDescription of the parent {@link IShoppingChannelCategory} type:\n\n> Category of channel.\n> \n> `IShoppingChannelCategory` is a concept that refers to classification\n> categories within a specific {@link IShoppingChannel channel}, and is exactly\n> the same as the concept commonly referred to as \"category\" in shopping malls.\n> \n> And `IShoppingChannelCategory` is different with {@link IShoppingSection}.\n> {@link IShoppingSection} refers to a \"corner\" that is independent spatial\n> information in the offline market, which cannot simultaneously classified in\n> a {@link IShoppingSale sale}. Besides, `IShoppingChannelCategory` can be\n> classified into multiple categories in a sale simultaneously.\n> \n> Product\t| Section (corner) | Categories\n> ---------|------------------|-----------------------------------\n> Beef\t    | Butcher corner   | Frozen food, Meat, Favorite food\n> Grape    | Fruit corner     | Fresh food, Favorite food\n> \n> In addition, as `IShoppingChannelCategory` has 1:N self recursive relationship,\n> it is possible to express below hierarchical structures. Thus, each channel\n> can set their own category classification as they want.\n> \n> - Food > Meat > Frozen\n> - Electronics > Notebook > 15 inches\n> - Miscellaneous > Wallet\n> \n> Furthermore, `IShoppingChannelCategory` is designed to merge between themselves,\n> so there is no burden to edit the category at any time."
          }
        },
        "required": [
          "channelCode",
          "body"
        ]
      },
      "description": "Create a new category.\n\nCreate a new {@link IShoppingChannelCategory category} of a\n{@link IShoppingChannel channel} with given name. If required, it is\npossible to specify the parent category by its ID."
    },
    {
      "name": "shoppings_admins_systematic_channels_categories_index",
      "parameters": {
        "type": "object",
        "properties": {
          "channelCode": {
            "type": "string",
            "description": " Belonged channel's {@link IShoppingChannel.code }"
          }
        },
        "required": [
          "channelCode"
        ]
      },
      "description": "List up every categories with children records.\n\nList up every {@link IShoppingChannelCategory.IHierarchical categories}\nof a {@link IShoppingChannel channel} with pagination. Returned categories\ncontain children categories, too.\n\nIf you want, you can limit the result by configuring\n{@link IShoppingChannelCategory.IRequest.search search condition} in the\nrequest body. Also, it is possible to customize sequence order of records\nby configuring {@link IShoppingChannelCategory.IRequest.sort sort condition}."
    },
    {
      "name": "shoppings_admins_systematic_channels_categories_at",
      "parameters": {
        "type": "object",
        "properties": {
          "channelCode": {
            "type": "string",
            "description": " Belonged channel's {@link IShoppingChannel.code }"
          },
          "id": {
            "type": "string",
            "description": " Target category's {@link IShoppingChannelCategory.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "channelCode",
          "id"
        ]
      },
      "description": "Get a category info.\n\nGet a detailed {@link IShoppingChannelCategory category} information.\n\nReturned category contains hierarchical children categories, and also\ncontains the recursive parent categories, too."
    },
    {
      "name": "shoppings_admins_systematic_channels_categories_update",
      "parameters": {
        "type": "object",
        "properties": {
          "channelCode": {
            "type": "string",
            "description": " Belonged channel's {@link IShoppingChannel.code }"
          },
          "id": {
            "type": "string",
            "description": " Target category's {@link IShoppingChannelCategory.id }"
          },
          "body": {
            "type": "object",
            "properties": {
              "parent_id": {
                "type": "string",
                "nullable": true,
                "description": "Parent category's ID.\n\n\n@format uuid"
              },
              "code": {
                "type": "string",
                "description": "Identifier code of the category.\n\nThe code must be unique in the channel."
              },
              "name": {
                "type": "string",
                "description": "Representative name of the category.\n\nThe name must be unique within the parent category. If no parent exists,\nthen the name must be unique within the channel between no parent\ncategories."
              }
            },
            "required": [
              "parent_id",
              "code",
              "name"
            ],
            "description": "Update info of the category\n\n------------------------------\n\nDescription of the current {@link IShoppingChannelCategory.ICreate} type:\n\n> Creation information of the category.\n\n------------------------------\n\nDescription of the parent {@link IShoppingChannelCategory} type:\n\n> Category of channel.\n> \n> `IShoppingChannelCategory` is a concept that refers to classification\n> categories within a specific {@link IShoppingChannel channel}, and is exactly\n> the same as the concept commonly referred to as \"category\" in shopping malls.\n> \n> And `IShoppingChannelCategory` is different with {@link IShoppingSection}.\n> {@link IShoppingSection} refers to a \"corner\" that is independent spatial\n> information in the offline market, which cannot simultaneously classified in\n> a {@link IShoppingSale sale}. Besides, `IShoppingChannelCategory` can be\n> classified into multiple categories in a sale simultaneously.\n> \n> Product\t| Section (corner) | Categories\n> ---------|------------------|-----------------------------------\n> Beef\t    | Butcher corner   | Frozen food, Meat, Favorite food\n> Grape    | Fruit corner     | Fresh food, Favorite food\n> \n> In addition, as `IShoppingChannelCategory` has 1:N self recursive relationship,\n> it is possible to express below hierarchical structures. Thus, each channel\n> can set their own category classification as they want.\n> \n> - Food > Meat > Frozen\n> - Electronics > Notebook > 15 inches\n> - Miscellaneous > Wallet\n> \n> Furthermore, `IShoppingChannelCategory` is designed to merge between themselves,\n> so there is no burden to edit the category at any time."
          }
        },
        "required": [
          "channelCode",
          "id",
          "body"
        ]
      },
      "description": "Update a category.\n\nUpdate a {@link IShoppingChannelCategory category}'s name. If required,\nit is possible to change the parent category by its ID. Of course, detaching\nfrom the parent category so that becoming the root category is also possible."
    },
    {
      "name": "shoppings_admins_systematic_channels_categories_merge",
      "parameters": {
        "type": "object",
        "properties": {
          "channelCode": {
            "type": "string",
            "description": " Belonged channel's {@link IShoppingChannel.code }"
          },
          "body": {
            "type": "object",
            "properties": {
              "keep": {
                "type": "string",
                "description": "Target record to keep after merging.\n\nAfter merge process, {@link absorbed} records would be merged into\nthis {@link keep} record.\n\n\n@format uuid"
              },
              "absorbed": {
                "type": "array",
                "items": {
                  "type": "string",
                  "description": "@format uuid"
                },
                "description": "To be absorbed to {@link keep} after merging."
              }
            },
            "required": [
              "keep",
              "absorbed"
            ],
            "description": "Merge info of the categories\n\n------------------------------\n\nDescription of the current {@link IRecordMerge} type:\n\n> Record Merge DTO.\n> \n> `IRecordMerge` is a structure for merging records.\n> \n> The `merge` means that merging multiple {@link IRecordMerge.absorbed}\n> records into {@link IRecordMerge.keep} instead of deleting\n> {@link IRecordMerge.absorbed} records.\n> \n> If there're some dependent tables of the target `table` having\n> unique constraint on foreign key column, such dependent tables\n> also perform the merge process, too.\n> \n> Of course, if there're another dependent tables under those\n> dependents, they also perform the merge process recursively as well.\n> Such recursive merge process still works for self-recursive\n> (tree-structured) tables."
          }
        },
        "required": [
          "channelCode",
          "body"
        ]
      },
      "description": "Merge multiple categories into one.\n\nIn this shopping mall system, it is not possible to delete a\n{@link IShoppingChannelCategory category}, because it is a systematic\nentity affecting to all other core entities like\n{@link IShoppingSale sales}. Instead of deleting, you can merge multiple\ncategories into one.\n\nIf you specify a category to absorb others, then all of other categories\nwill be merged into the specified one. Also, subsidiary entities of\ncategories also be merged and their references also be merged cascadingly."
    },
    {
      "name": "shoppings_admins_systematic_channels_categories_invert",
      "parameters": {
        "type": "object",
        "properties": {
          "channelCode": {
            "type": "string",
            "description": " Belonged channel's {@link IShoppingChannel.code }"
          },
          "id": {
            "type": "string",
            "description": " Target category's {@link IShoppingChannelCategory.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "channelCode",
          "id"
        ]
      },
      "description": "Get a category info of inverted.\n\nGet a inverted {@link IShoppingChannelCategory.IInvert category} information.\n\nReturned category contains the recursive parent categories, but not contains\nthe hierarchical children categories."
    },
    {
      "name": "shoppings_admins_systematic_channels_create",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "code": {
                "type": "string",
                "description": "Identifier code."
              },
              "name": {
                "type": "string",
                "description": "Name of the channel."
              }
            },
            "required": [
              "code",
              "name"
            ],
            "description": "Creation info of the channel\n\n------------------------------\n\nDescription of the current {@link IShoppingChannel.ICreate} type:\n\n> Creation information of the channel.\n\n------------------------------\n\nDescription of the parent {@link IShoppingChannel} type:\n\n> Channel information.\n> \n> `IShoppingChannel` is a concept that shapes the distribution channel in the\n> market. Therefore, the difference in the channel in this e-commerce system\n> means that it is another site or application.\n> \n> By the way, if your shopping mall system requires only one channel, then\n> just use only one. This concept is designed to be expandable in the future."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "Create a new channel.\n\nCreate a new {@link IShoppingChannel channel} with given code and name.\n\nAs channel means an individual market,\n{@link IShoppingAdministrator administrator} should perform this action\nonly when a new application being registered."
    },
    {
      "name": "shoppings_admins_systematic_channels_index",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "search": {
                "type": "object",
                "properties": {
                  "code": {
                    "type": "string",
                    "nullable": true
                  },
                  "name": {
                    "type": "string",
                    "nullable": true
                  }
                },
                "required": [],
                "nullable": true
              },
              "sort": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "-channel.code",
                    "-channel.name",
                    "-channel.created_at",
                    "+channel.code",
                    "+channel.name",
                    "+channel.created_at"
                  ]
                },
                "nullable": true
              },
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Request info of pagination, searching and sorting\n\n------------------------------\n\nDescription of the current {@link IShoppingChannel.IRequest} type:\n\n> Request of the channels with pagination and searching/sorting options.\n\n------------------------------\n\nDescription of the parent {@link IShoppingChannel} type:\n\n> Channel information.\n> \n> `IShoppingChannel` is a concept that shapes the distribution channel in the\n> market. Therefore, the difference in the channel in this e-commerce system\n> means that it is another site or application.\n> \n> By the way, if your shopping mall system requires only one channel, then\n> just use only one. This concept is designed to be expandable in the future."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "List up every channels.\n\nList up every {@link IShoppingChannel channels} with pagination.\n\nIf you want, you can limit the result by configuring\n{@link IShoppingChannel.IRequest.search search condition} in the request\nbody. Also, it is possible to customize sequence order of records by\nconfiguring {@link IShoppingChannel.IRequest.sort sort condition}."
    },
    {
      "name": "shoppings_admins_systematic_channels_at",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target channel's {@link IShoppingChannel.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Get a channel info.\n\nGet a detailed {@link IShoppingChannel.IHierarchical channel} information.\n\nReturned channel instance also contains the nested\n{@link IShoppingChannelCategory.IHierarchical hierarchical category}\ninformation."
    },
    {
      "name": "shoppings_admins_systematic_channels_update",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target channel's {@link IShoppingChannel.code }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the channel."
              }
            },
            "required": [
              "name"
            ],
            "description": "Update info of the channel\n\n------------------------------\n\nDescription of the current {@link IShoppingChannel.IUpdate} type:\n\n> Updating information of the channel.\n\n------------------------------\n\nDescription of the parent {@link IShoppingChannel} type:\n\n> Channel information.\n> \n> `IShoppingChannel` is a concept that shapes the distribution channel in the\n> market. Therefore, the difference in the channel in this e-commerce system\n> means that it is another site or application.\n> \n> By the way, if your shopping mall system requires only one channel, then\n> just use only one. This concept is designed to be expandable in the future."
          }
        },
        "required": [
          "id",
          "body"
        ]
      },
      "description": "Update a channel.\n\nUpdate a {@link IShoppingChannel channel}'s name.\n\nNote that, it is not possible to change the channel's code. If you want to\nto do it forcibly, then {@link create} new one and {@link merge} with it."
    },
    {
      "name": "shoppings_admins_systematic_channels_merge",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "keep": {
                "type": "string",
                "description": "Target record to keep after merging.\n\nAfter merge process, {@link absorbed} records would be merged into\nthis {@link keep} record.\n\n\n@format uuid"
              },
              "absorbed": {
                "type": "array",
                "items": {
                  "type": "string",
                  "description": "@format uuid"
                },
                "description": "To be absorbed to {@link keep} after merging."
              }
            },
            "required": [
              "keep",
              "absorbed"
            ],
            "description": "Request info of the merge\n\n------------------------------\n\nDescription of the current {@link IRecordMerge} type:\n\n> Record Merge DTO.\n> \n> `IRecordMerge` is a structure for merging records.\n> \n> The `merge` means that merging multiple {@link IRecordMerge.absorbed}\n> records into {@link IRecordMerge.keep} instead of deleting\n> {@link IRecordMerge.absorbed} records.\n> \n> If there're some dependent tables of the target `table` having\n> unique constraint on foreign key column, such dependent tables\n> also perform the merge process, too.\n> \n> Of course, if there're another dependent tables under those\n> dependents, they also perform the merge process recursively as well.\n> Such recursive merge process still works for self-recursive\n> (tree-structured) tables."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "Merge multiple channels into one.\n\nIn this shopping mall system, it is not possible to delete a\n{@link IShoppingChannel channel}, because it is a systematic entity\naffecting to all other core entities like customers, members and\nsales. Instead of deleting, you can merge multiple channels into one.\n\nIf you specify a channel to absorb others, then all of other channels\nwill be merged into the specified one. Also, subsidiary entities of\nchannels also be merged and their references also be merged cascadingly."
    },
    {
      "name": "shoppings_admins_systematic_channels_hierarchical",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "search": {
                "type": "object",
                "properties": {
                  "code": {
                    "type": "string",
                    "nullable": true
                  },
                  "name": {
                    "type": "string",
                    "nullable": true
                  }
                },
                "required": [],
                "nullable": true
              },
              "sort": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "-channel.code",
                    "-channel.name",
                    "-channel.created_at",
                    "+channel.code",
                    "+channel.name",
                    "+channel.created_at"
                  ]
                },
                "nullable": true
              },
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Request info of pagination, searching and sorting\n\n------------------------------\n\nDescription of the current {@link IShoppingChannel.IRequest} type:\n\n> Request of the channels with pagination and searching/sorting options.\n\n------------------------------\n\nDescription of the parent {@link IShoppingChannel} type:\n\n> Channel information.\n> \n> `IShoppingChannel` is a concept that shapes the distribution channel in the\n> market. Therefore, the difference in the channel in this e-commerce system\n> means that it is another site or application.\n> \n> By the way, if your shopping mall system requires only one channel, then\n> just use only one. This concept is designed to be expandable in the future."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "List up every channels with nested categories.\n\nList up every {@link IShoppingChannel.IHierarchical channels} with\n{@link IPage pagination}. Returned channels contain nested hierarchical\n{@link IShoppingChannelCategory.IHierarchical categories}.\n\nIf you want, you can limit the result by configuring\n{@link IShoppingChannel.IRequest.search search condition} in the request\nbody. Also, it is possible to customize sequence order of records by\nconfiguring {@link IShoppingChannel.IRequest.sort sort condition}."
    },
    {
      "name": "shoppings_admins_systematic_channels_get",
      "parameters": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "description": " Target channel's {@link IShoppingChannel.code }"
          }
        },
        "required": [
          "code"
        ]
      },
      "description": "Get a channel info by its code.\n\nGet a detailed {@link IShoppingChannel.IHierarchical channel} information\nby its code.\n\nReturned channel instance also contains the nested\n{@link IShoppingChannelCategory.IHierarchical hierarchical category}\ninformation."
    },
    {
      "name": "shoppings_admins_systematic_sections_create",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "code": {
                "type": "string",
                "description": "Identifier code."
              },
              "name": {
                "type": "string",
                "description": "Representative name of the section."
              }
            },
            "required": [
              "code",
              "name"
            ],
            "description": "Creation info of the section\n\n------------------------------\n\nDescription of the current {@link IShoppingSection.ICreate} type:\n\n> Creation information of the section.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSection} type:\n\n> Section information.\n> \n> `IShoppingSection` is a concept that refers to the spatial information of\n> the market.\n> \n> If we compare the section mentioned here to the offline market, it means a\n> spatially separated area within the store, such as the \"fruit corner\" or\n> \"butcher corner\". Therefore, in the {@link IShoppingSale sale} entity, it is\n> not possible to classify multiple sections simultaneously, but only one section\n> can be classified.\n> \n> By the way, if your shopping mall system requires only one section, then just\n> use only one. This concept is designed to be expandable in the future."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "Create a new section.\n\nCreate a new {@link IShoppingSection section} with given code and name.\n\nAs section means a spatial unit of a market that handling different type\nof products with other section, {@link IShoppingAdministrator administrator}\nshould perform this action only when a new section being required."
    },
    {
      "name": "shoppings_admins_systematic_sections_index",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "search": {
                "type": "object",
                "properties": {
                  "code": {
                    "type": "string",
                    "nullable": true
                  },
                  "name": {
                    "type": "string",
                    "nullable": true
                  }
                },
                "required": [],
                "nullable": true
              },
              "sort": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "-section.code",
                    "-section.name",
                    "-section.created_at",
                    "+section.code",
                    "+section.name",
                    "+section.created_at"
                  ]
                },
                "nullable": true
              },
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Request info of pagination, searching and sorting\n\n------------------------------\n\nDescription of the current {@link IShoppingSection.IRequest} type:\n\n> Request of the sections with pagination and searching/sorting options.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSection} type:\n\n> Section information.\n> \n> `IShoppingSection` is a concept that refers to the spatial information of\n> the market.\n> \n> If we compare the section mentioned here to the offline market, it means a\n> spatially separated area within the store, such as the \"fruit corner\" or\n> \"butcher corner\". Therefore, in the {@link IShoppingSale sale} entity, it is\n> not possible to classify multiple sections simultaneously, but only one section\n> can be classified.\n> \n> By the way, if your shopping mall system requires only one section, then just\n> use only one. This concept is designed to be expandable in the future."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "List up every sections.\n\nList up every {@link IShoppingSection sections} with pagination.\n\nIf you want, you can limit the result by configuring\n{@link IShoppingSection.IRequest.search search condition} in the request\nbody. Also, it is possible to customize sequence order of records by\nconfiguring {@link IShoppingSection.IRequest.sort sort condition}."
    },
    {
      "name": "shoppings_admins_systematic_sections_at",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target section's {@link IShoppingSection.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Get a section info.\n\nGet a detailed {@link IShoppingSection section} information."
    },
    {
      "name": "shoppings_admins_systematic_sections_update",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target section's {@link IShoppingSection.code }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "description": "Representative name of the section."
              }
            },
            "required": [
              "name"
            ],
            "description": "Update info of the section\n\n------------------------------\n\nDescription of the current {@link IShoppingSection.IUpdate} type:\n\n> Updating information of the section.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSection} type:\n\n> Section information.\n> \n> `IShoppingSection` is a concept that refers to the spatial information of\n> the market.\n> \n> If we compare the section mentioned here to the offline market, it means a\n> spatially separated area within the store, such as the \"fruit corner\" or\n> \"butcher corner\". Therefore, in the {@link IShoppingSale sale} entity, it is\n> not possible to classify multiple sections simultaneously, but only one section\n> can be classified.\n> \n> By the way, if your shopping mall system requires only one section, then just\n> use only one. This concept is designed to be expandable in the future."
          }
        },
        "required": [
          "id",
          "body"
        ]
      },
      "description": "Update a section.\n\nUpdate a {@link IShoppingSection section}'s name.\n\nNote that, it is not possible to change the section's code. If you want to\nto do it forcibly, then {@link create} new one and {@link merge} with it."
    },
    {
      "name": "shoppings_admins_systematic_sections_merge",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "keep": {
                "type": "string",
                "description": "Target record to keep after merging.\n\nAfter merge process, {@link absorbed} records would be merged into\nthis {@link keep} record.\n\n\n@format uuid"
              },
              "absorbed": {
                "type": "array",
                "items": {
                  "type": "string",
                  "description": "@format uuid"
                },
                "description": "To be absorbed to {@link keep} after merging."
              }
            },
            "required": [
              "keep",
              "absorbed"
            ],
            "description": "input Request info of the merge\n\n------------------------------\n\nDescription of the current {@link IRecordMerge} type:\n\n> Record Merge DTO.\n> \n> `IRecordMerge` is a structure for merging records.\n> \n> The `merge` means that merging multiple {@link IRecordMerge.absorbed}\n> records into {@link IRecordMerge.keep} instead of deleting\n> {@link IRecordMerge.absorbed} records.\n> \n> If there're some dependent tables of the target `table` having\n> unique constraint on foreign key column, such dependent tables\n> also perform the merge process, too.\n> \n> Of course, if there're another dependent tables under those\n> dependents, they also perform the merge process recursively as well.\n> Such recursive merge process still works for self-recursive\n> (tree-structured) tables."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "Merge multiple sections into one.\n\nIn this shopping mall system, it is not possible to delete a\n{@link IShoppingSection section}, because it is a systematic entity\naffecting to all other core entities like {@link IShoppingSale sales}.\nInstead of deleting, you can merge multiple sections into one.\n\nIf you specify a section to absorb others, then all of other sections\nwill be merged into the specified one. Also, subsidiary entities of\nsections also be merged and their references also be merged cascadingly."
    },
    {
      "name": "shoppings_admins_systematic_sections_get",
      "parameters": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "description": " Target section's {@link IShoppingSection.code }"
          }
        },
        "required": [
          "code"
        ]
      },
      "description": "Get a section info by its code.\n\nGet a detailed {@link IShoppingSection section} information by its code."
    },
    {
      "name": "shoppings_customers_authenticate_password_change",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "oldbie": {
                "type": "string",
                "description": "Current password."
              },
              "newbie": {
                "type": "string",
                "description": "The new password to change."
              }
            },
            "required": [
              "oldbie",
              "newbie"
            ],
            "description": "New password and current password\n\n------------------------------\n\nDescription of the current {@link IShoppingMember.IPasswordChange} type:\n\n> Request info of password change.\n\n------------------------------\n\nDescription of the parent {@link IShoppingMember} type:\n\n> Member Account.\n> \n> `IShoppingMember` is an entity that symbolizes the case when a\n> {@link IShoppingCustomer} signs up as a member of this shopping mall\n> system.\n> \n> If a `IShoppingMember` has seller or administrator property. it means that\n> the {@link IShoppingCustomer} has acting as a {@link IShoppingSeller seller}\n> or {@link IShoppingAdministrator administrator} at the same time."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "Change password.\n\nChange password of {@link IShoppingMember member} with the current password.\n\nThe reason why the current password is required is for security."
    },
    {
      "name": "shoppings_customers_deposits_charges_update",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target deposit charge's {@link IShoppingDepositCharge.id }"
          },
          "body": {
            "type": "object",
            "properties": {
              "value": {
                "type": "number"
              }
            },
            "required": [
              "value"
            ],
            "description": "Value to change\n\n------------------------------\n\nCurrent Type: {@link IShoppingDepositCharge.ICreate}"
          }
        },
        "required": [
          "id",
          "body"
        ]
      },
      "description": "Update a deposit charge application.\n\nUpdate value of a {@link IShoppingDepositCharge deposit charge application}\nthat has been applied by the {@link IShoppingCustomer}.\n\nIf the charge has been {@link IShoppingDepositChargePublish published},\nthen it is not possible to update the deposit charge. Only 410 gone exception\nwould be thrown."
    },
    {
      "name": "shoppings_customers_deposits_charges_erase",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target deposit charge's {@link IShoppingDepositCharge.id }"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Erase a deposit charge application.\n\nErase a {@link IShoppingDepositCharge deposit charge application} that has been\napplied by the {@link IShoppingCustomer}.\n\nIf the charge has been {@link IShoppingDepositChargePublish published}, then\nit is not possible to erase the deposit charge. In that case, you've to cancel\nthe payment by calling the {@link publish.cancel} function."
    },
    {
      "name": "shoppings_customers_deposits_charges_publish_able",
      "parameters": {
        "type": "object",
        "properties": {
          "chargeId": {
            "type": "string",
            "description": " Target charge's {@link IShoppingDepositCharge.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "chargeId"
        ]
      },
      "description": "Check publishable.\n\nTest whether the {@link IShoppingDepositCharge charge} is publishable or not.\n\nIf the charge has not been {@link IShoppingDepositChargePublish published} and\nnot deleted yet, then it is possible to publish the charge"
    },
    {
      "name": "shoppings_customers_deposits_charges_publish_create",
      "parameters": {
        "type": "object",
        "properties": {
          "chargeId": {
            "type": "string",
            "description": " Target charge's {@link IShoppingDepositCharge.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "vendor": {
                "type": "string"
              },
              "uid": {
                "type": "string"
              }
            },
            "required": [
              "vendor",
              "uid"
            ],
            "description": "Creation info of the publish\n\n------------------------------\n\nCurrent Type: {@link IShoppingDepositChargePublish.ICreate}"
          }
        },
        "required": [
          "chargeId",
          "body"
        ]
      },
      "description": "Publish a charge.\n\n{@link IShoppingDepositChargePublish Publish} a\n{@link IShoppingDepositCharge charge} that has been applied by the\n{@link IShoppingCustomer} with payment information gotten from the\npayment vendor system.\n\nAlso, the payment time can be different with the publish time. For example,\nif the payment method is manual bank account transfer, then the payment\nwould be delayed until the customer actually transfer the money. In that\ncase, {@link IShoppingDepositChargePublish.paid_at} would be `null` value,\nso that you have to check it after calling this publish function."
    },
    {
      "name": "shoppings_customers_deposits_histories_index",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "search": {
                "type": "object",
                "properties": {
                  "deposit": {
                    "type": "object",
                    "properties": {
                      "source": {
                        "type": "string",
                        "nullable": true
                      },
                      "code": {
                        "type": "string",
                        "nullable": true
                      },
                      "direction": {
                        "type": "number",
                        "enum": [
                          -1,
                          1
                        ],
                        "nullable": true
                      }
                    },
                    "required": [],
                    "nullable": true
                  },
                  "citizen_id": {
                    "type": "string",
                    "nullable": true,
                    "description": "@format uuid"
                  },
                  "from": {
                    "type": "string",
                    "nullable": true,
                    "description": "@format date-time"
                  },
                  "to": {
                    "type": "string",
                    "nullable": true,
                    "description": "@format date-time"
                  },
                  "minimum": {
                    "type": "number",
                    "nullable": true,
                    "description": "@minimum 0"
                  },
                  "maximum": {
                    "type": "number",
                    "nullable": true,
                    "description": "@minimum 0"
                  }
                },
                "required": [],
                "nullable": true
              },
              "sort": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "-deposit.source",
                    "-deposit.code",
                    "-deposit.direction",
                    "+deposit.source",
                    "+deposit.code",
                    "+deposit.direction",
                    "-history.value",
                    "-history.created_at",
                    "+history.value",
                    "+history.created_at"
                  ]
                },
                "nullable": true
              },
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Request info of pagination, searching and sorting\n\n------------------------------\n\nCurrent Type: {@link IShoppingDepositHistory.IRequest}"
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "List up every deposit histories.\n\nList up every {@link IShoppingDepositHistory deposit histories} of the\n{@link IShoppingCustomer customer} with {@link IPage pagination}.\n\nIf you want, you can limit the result by configuring\n{@link IShoppingDepositHistory.IRequest.search search condition} in the\nrequest body. Also, it is possible to customize sequence order of records\nby configuring {@link IShoppingDepositHistory.IRequest.sort sort condition}."
    },
    {
      "name": "shoppings_customers_deposits_histories_at",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "@format uuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Get a deposit history info.\n\nGet a {@link IShoppingDepositHistory deposit history} information."
    },
    {
      "name": "shoppings_customers_deposits_histories_balance",
      "parameters": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "description": "Get balance of the deposit.\n\nGet current balance of the deposit of the {@link IShoppingCustomer customer}."
    },
    {
      "name": "shoppings_customers_mileages_histories_index",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "search": {
                "type": "object",
                "properties": {
                  "mileage": {
                    "type": "object",
                    "properties": {
                      "source": {
                        "type": "string",
                        "nullable": true
                      },
                      "code": {
                        "type": "string",
                        "nullable": true
                      },
                      "direction": {
                        "type": "number",
                        "enum": [
                          -1,
                          1
                        ],
                        "nullable": true
                      }
                    },
                    "required": [],
                    "nullable": true
                  },
                  "citizen_id": {
                    "type": "string",
                    "nullable": true,
                    "description": "@format uuid"
                  },
                  "from": {
                    "type": "string",
                    "nullable": true,
                    "description": "@format date-time"
                  },
                  "to": {
                    "type": "string",
                    "nullable": true,
                    "description": "@format date-time"
                  },
                  "minimum": {
                    "type": "number",
                    "nullable": true,
                    "description": "@minimum 0"
                  },
                  "maximum": {
                    "type": "number",
                    "nullable": true,
                    "description": "@minimum 0"
                  }
                },
                "required": [],
                "nullable": true
              },
              "sort": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "-mileage.source",
                    "-mileage.code",
                    "-mileage.direction",
                    "+mileage.source",
                    "+mileage.code",
                    "+mileage.direction",
                    "-history.value",
                    "-history.created_at",
                    "+history.value",
                    "+history.created_at"
                  ]
                },
                "nullable": true
              },
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Request info of pagination, searching and sorting\n\n------------------------------\n\nCurrent Type: {@link IShoppingMileageHistory.IRequest}"
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "List up every mileage histories.\n\nList up every {@link IShoppingMileageHistory mileage histories} of the\n{@link IShoppingCustomer customer} with {@link IPage pagination}.\n\nIf you want, you can limit the result by configuring\n{@link IShoppingMileageHistory.IRequest.search search condition} in the\nrequest body. Also, it is possible to customize sequence order of records\nby configuring {@link IShoppingMileageHistory.IRequest.sort sort condition}."
    },
    {
      "name": "shoppings_customers_mileages_histories_at",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target mileage history's {@link IShoppingMileageHistory.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Get a mileage history info.\n\nGet a {@link IShoppingMileageHistory mileage history} information."
    },
    {
      "name": "shoppings_customers_mileages_histories_balance",
      "parameters": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "description": "Get balance of the mileage.\n\nGet current balance of the mileage of the {@link IShoppingCustomer customer}."
    },
    {
      "name": "shoppings_customers_carts_commodities_update",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target commodity's {@link IShoppingCartCommodity.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "volume": {
                "type": "integer",
                "description": "Volume of the commodity to purchase.\n\nA value indicating how many sets would be multiplied to the children\n{@link IShoppingSaleUnitStock.IInvert.quantity} values.\n\n\n@minimum 1"
              }
            },
            "required": [
              "volume"
            ],
            "description": "Update info of the commodity (volume)\n\n------------------------------\n\nDescription of the current {@link IShoppingCartCommodity.IUpdate} type:\n\n> Update information of a shopping cart commodity.\n\n------------------------------\n\nDescription of the parent {@link IShoppingCartCommodity} type:\n\n> Item in a shopping cart.\n> \n> `IShoppingCartCommodity` is an entity that represents a\n> {@link IShoppingSaleSnapshot snapshot} of the items that\n> {@link IShoppingCustomer customer} has placed into his shopping cart with a\n> {@link IShoppingOrder purchase} in mind. And if the customer continues this\n> into an actual order in the future, `IShoppingCartCommodity` be changed to\n> {@link IShoppingOrderGood}.\n> \n> And while adding a sale snapshot to the shopping cart, the customer inevitably\n> selects specific {@link IShoppingSaleUnit units} and\n> {@link IShoppingSaleUnitStock final stocks} within the listing snapshot.\n> Information about these units and stocks is recorded in the subsidiary entity\n> {@link IShoppingCartCommodityStock}. Also, there is an attribute {@link volume}\n> that indicates how many sets of snapshots of the target commodity will be\n> purchased. This \"volume\" is a value that will be multiplied by\n> {@link IShoppingSaleUnitStock.IInvert.quantity}, the quantity for each\n> component."
          }
        },
        "required": [
          "id",
          "body"
        ]
      },
      "description": "Update a commodity (volume).\n\nUpdate a {@link IShoppingCartCommodity commodity}'s volume in the\nshopping cart.\n\nIf target {@link IShoppingSale sale} has been suspended or\n{@link IShoppingSaleUnitStockInventory out of stock} suddenly, then 410\ngone error would be thrown, either."
    },
    {
      "name": "shoppings_customers_carts_commodities_erase",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target commodity's {@link IShoppingCartCommodity.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Erase a commodity.\n\nErase a {@link IShoppingCartCommodity commodity} from the shopping cart.\n\nIf the commodity is on an {@link IShoppingOrder order} process, it is not\npossible to erase it. Instead, if the order has been\n{@link IShoppingOrderPublish published}, then it would not be appread in\nthe shopping cart more. If the order be erased, then you also can continue\nerasinng the commodity, neither."
    },
    {
      "name": "shoppings_customers_orders_erase",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target order's {@link IShoppingOrder.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Erase an order application.\n\nErase an order application that has been applied by the\n{@link IShoppingCustomer}.\n\nIf the order has been {@link IShoppingOrderPublish published}, then it is\nnot possible to erase the order. In that case, you've to cancel the\npayment by calling the {@link publish.cancel} function."
    },
    {
      "name": "shoppings_customers_orders_goods_confirm",
      "parameters": {
        "type": "object",
        "properties": {
          "orderId": {
            "type": "string",
            "description": " Belonged order's {@link IShoppingOrder.id }\n\n\n@format uuid"
          },
          "id": {
            "type": "string",
            "description": " Target good's {@link IShoppingOrderGood.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "orderId",
          "id"
        ]
      },
      "description": "Confirm an order good.\n\nConfirm an {@link IShoppingOrderGood order good} that has been\ncompleted {@link IShoppingDelivery delivering} to the\n{@link IShoppingCustomer customer}.\n\nIn other words, belonged {@link IShoppingOrder order} must be\n{@link IShoppingPublish.paid_at published, paid} and delivery of\nthe good must be {@link IShoppingDeliveryJourney arrived} to the\ncustomer. If not, 428 unprocessable entity error would be thrown."
    },
    {
      "name": "shoppings_customers_orders_publish_able",
      "parameters": {
        "type": "object",
        "properties": {
          "orderId": {
            "type": "string",
            "description": " Target order's {@link IShoppingOrder.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "orderId"
        ]
      },
      "description": "Check publishable.\n\nTest whether the {@link IShoppingOrder order} is publishable or not.\n\nIf the order has not been {@link IShoppingOrderPublish published} and\nnot deleted yet, then it is possible to publish the order. Even thouogh\ntarget {@link IShoppingSale sale} is suspended or\n{@link IShoppingSaleUnitStockInventory out of stock}, it is still possible\nto publish because the order already has been applied."
    },
    {
      "name": "shoppings_customers_orders_publish_create",
      "parameters": {
        "type": "object",
        "properties": {
          "orderId": {
            "type": "string",
            "description": " Target order's {@link IShoppingOrder.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "address": {
                "type": "object",
                "properties": {
                  "mobile": {
                    "type": "string",
                    "description": "Mobile number to contact.\n\n\n@pattern ^[0-9]*$"
                  },
                  "name": {
                    "type": "string",
                    "description": "Representative name of the address.\n\nSometimes be receiver's name, and sometimes be place name."
                  },
                  "country": {
                    "type": "string",
                    "description": "Country name."
                  },
                  "province": {
                    "type": "string",
                    "description": "Province name."
                  },
                  "city": {
                    "type": "string",
                    "description": "City name."
                  },
                  "department": {
                    "type": "string",
                    "description": "Department name."
                  },
                  "possession": {
                    "type": "string",
                    "description": "Detailed address containing street name, building number, and room number."
                  },
                  "zip_code": {
                    "type": "string",
                    "description": "Zip code, or postal code."
                  },
                  "special_note": {
                    "type": "string",
                    "nullable": true,
                    "description": "Special description if required."
                  }
                },
                "required": [
                  "mobile",
                  "name",
                  "country",
                  "province",
                  "city",
                  "department",
                  "possession",
                  "zip_code",
                  "special_note"
                ],
                "description": "Address to receive.\n\n------------------------------\n\nCurrent Type: {@link IShoppingAddress.ICreate}\n\n------------------------------\n\nDescription of the parent {@link IShoppingAddress} type:\n\n> The address information."
              },
              "vendor": {
                "type": "object",
                "properties": {
                  "code": {
                    "type": "string",
                    "x-wrtn-payment-vendor": true,
                    "description": "The vendor code who will receive the payment."
                  },
                  "uid": {
                    "type": "string",
                    "x-wrtn-payment-uid": true,
                    "description": "The payment uid."
                  }
                },
                "required": [
                  "code",
                  "uid"
                ],
                "description": "Payment identifier from the payment vendor service.\n\nIf the order has been discounted for entire order price, then no need\nto send payment vendor info. Instead, you just configure the `null`\nvalue to this property.",
                "nullable": true
              }
            },
            "required": [
              "address",
              "vendor"
            ],
            "description": "Creation info of the publish\n\n------------------------------\n\nDescription of the current {@link IShoppingOrderPublish.ICreate} type:\n\n> Creation info of the publish.\n\n------------------------------\n\nDescription of the parent {@link IShoppingOrderPublish} type:\n\n> Order completion and payment information.\n> \n> `IShoppingOrderPublish` is an entity that embodies the series of processes\n> in which a {@link IShoppingCustomer customer} pays for his or her\n> {@link IShoppingOrder order}, thereby completing the order. And only after\n> the order is {@link paid_at completed}, can the {@link IShoppingSeller seller}\n> recognize that the customer has purchased his product.\n> \n> By the way, please note that just because the `IShoppingOrderPublish` record\n> exists, it does not mean that the payment has been completed. Of course, with\n> \"credit cards\" and \"Google Pay\", payment application and payment occur at the\n> same time. However, there are some cases where payment is made after the\n> payment application, such as \"bank transfer\" or \"virtual account payment\".\n> Therefore, to see the completion of payment, be sure to check the\n> {@link paid_at} property.\n> \n> In addition, even after payment has been made, there may be cases where it is\n> suddenly cancelled, so please be aware of this as well."
          }
        },
        "required": [
          "orderId",
          "body"
        ]
      },
      "description": "Publish an order.\n\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\nhas been applied by the {@link IShoppingCustomer} with\n{@link IShoppingAddress address} to delivery and payment information gotten\nfrom the payment vendor system.\n\nIf the order has been discounted for entire order price, then no need\nto send payment vendor info. Instead, only address info is required.\n\nAlso, the payment time can be different with the publish time. For example,\nif the payment method is manual bank account transfer, then the payment\nwould be delayed until the customer actually transfer the money. In that\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\nthat you have to check it after calling this publish function."
    },
    {
      "name": "shoppings_customers_orders_publish_cancel",
      "parameters": {
        "type": "object",
        "properties": {
          "orderId": {
            "type": "string",
            "description": " Target order's {@link IShoppingOrder.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "orderId"
        ]
      },
      "description": "Cancel the publish (payment).\n\nCancel payment of an {@link IShoppingOrder order} that has been\n{@link IShoppingOrderPublish published}.\n\nIf target publish's payment method is manual bank account transfer,\nthen it would be cancelled directly. If not, then payment cancel\nrequest would be sent to the payment vendor system."
    },
    {
      "name": "shoppings_customers_sales_index",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "sort": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "-seller.created_at",
                    "-seller.goods.payments.real",
                    "-seller.goods.publish_count",
                    "-seller.reviews.average",
                    "-seller.reviews.count",
                    "-goods.publish_count",
                    "-goods.payments.real",
                    "-reviews.average",
                    "-reviews.count",
                    "-sale.created_at",
                    "-sale.updated_at",
                    "-sale.opened_at",
                    "-sale.closed_at",
                    "-sale.content.title",
                    "-sale.price_range.lowest.real",
                    "-sale.price_range.highest.real",
                    "+seller.created_at",
                    "+seller.goods.payments.real",
                    "+seller.goods.publish_count",
                    "+seller.reviews.average",
                    "+seller.reviews.count",
                    "+goods.publish_count",
                    "+goods.payments.real",
                    "+reviews.average",
                    "+reviews.count",
                    "+sale.created_at",
                    "+sale.updated_at",
                    "+sale.opened_at",
                    "+sale.closed_at",
                    "+sale.content.title",
                    "+sale.price_range.lowest.real",
                    "+sale.price_range.highest.real"
                  ]
                },
                "nullable": true,
                "description": "Sorting conditions."
              },
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Request info of pagination, searching and sorting\n\n------------------------------\n\nDescription of the current {@link IShoppingSale.IRequest} type:\n\n> Request of summarized sales with pagination and searching/sorting options.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSale} type:\n\n> Seller sales products.\n> \n> `IShoppingSale` is an entity that embodies \"product sales\" (sales)\n> information registered by the {@link ISoppingSeller seller}. And the main\n> information of the sale is recorded in the sub {@link IShoppingSaleSnapshot},\n> not in the main `IShoppingSale`. When a seller changes a previously registered\n> item, the existing `IShoppingSale` record is not changed, but a new\n> {@link IShoppingSaleSnapshot snapshot} record be created.\n> \n> This is to preserve the {@link IShoppingCustomer customer}'s\n> {@link IShoppingOrder purchase history} flawlessly after the customer\n> purchases a specific item, even if the seller changes the components or\n> price of the item. It is also intended to support sellers in so-called A/B\n> testing, which involves changing components or prices and measuring the\n> performance in each case."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "List up every summarized sales.\n\nList up every {@link IShoppingSale.ISummary summarized sales}.\n\nAs you can see, returned sales are summarized, not detailed. It does not\ncontain the SKU (Stock Keeping Unit) information represented by the\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\nIf you want to get such detailed information of a sale, use\n`GET /shoppings/customers/sales/{id}` operation for each sale.\n\n> If you're an A.I. chatbot, and the user wants to buy or compose\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\n> to the target sale to get detailed SKU information about the sale.\n> It needs to be run at least once for the next steps."
    },
    {
      "name": "shoppings_customers_sales_questions_comments_update",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Belonged sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "inquiryId": {
            "type": "string",
            "description": " Belonged inquiry's {@link IShoppingSaleInquiry.id }\n\n\n@format uuid"
          },
          "id": {
            "type": "string",
            "description": " Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "format": {
                "type": "string",
                "enum": [
                  "html",
                  "md",
                  "txt"
                ],
                "description": "Format of body.\n\nSame meaning with extension like `html`, `md`, `txt`."
              },
              "body": {
                "type": "string",
                "description": "Content body of comment."
              },
              "files": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "File name, except extension.\n\nIf there's file `.gitignore`, then its name is an empty string.\n\n\n@maxLength 255"
                    },
                    "extension": {
                      "type": "string",
                      "nullable": true,
                      "description": "Extension.\n\nPossible to omit like `README` case.\n\n\n@minLength 1\n@maxLength 8"
                    },
                    "url": {
                      "type": "string",
                      "description": "URL path of the real file.\n\n\n@format uri\n@contentMediaType image/*"
                    }
                  },
                  "required": [
                    "name",
                    "extension",
                    "url"
                  ],
                  "description": "Current Type: {@link IAttachmentFile.ICreate}\n\n------------------------------\n\nDescription of the parent {@link IAttachmentFile} type:\n\n> Attachment File.\n> \n> Every attachment files that are managed in current system.\n> \n> For reference, it is possible to omit one of file {@link name}\n> or {@link extension} like `.gitignore` or `README` case, but not\n> possible to omit both of them."
                },
                "description": "List of attachment files."
              }
            },
            "required": [
              "format",
              "body",
              "files"
            ],
            "description": "Update info of the inquiry comment\n\n------------------------------\n\nDescription of the current {@link IShoppingSaleInquiryComment.ICreate} type:\n\n> Creation information of the comment.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSaleInquiryComment} type:\n\n> A comment written on an inquiry article.\n> \n> `IShoppingSaleInquiryComment` is a subtype entity of {@link IBbsArticleComment},\n> and is used when you want to communicate with multiple people about an\n> {@link IShoppingSaleInquiry inquiry} written by a\n> {@link IShoppingCustomer customer}.\n> \n> For reference, only related parties can write comments for\n> {@link IShoppingSeller sellers}, but there is no limit to\n> {@link IShoppingCustomer customers}. In other words, anyone customer can\n> freely write a comment, even if they are not the person who wrote the inquiry."
          }
        },
        "required": [
          "saleId",
          "inquiryId",
          "id",
          "body"
        ]
      },
      "description": "Update an inquiry comment.\n\nUpdate an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n\nBy the way, as is the general policy of this shopping mall regarding\ncomments, modifying a comment does not actually change the existing content.\nModified content is accumulated and recorded in the existing comment record\nas a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this\nis made public to everyone, who can read this inquiry comment.\n\nThis is to prevent customers or sellers from modifying their comments and\nmanipulating the circumstances due to the nature of e-commerce, where\ndisputes easily arise. That is, to preserve evidence."
    },
    {
      "name": "shoppings_customers_sales_questions_update",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Belonged sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "id": {
            "type": "string",
            "description": " Target question's {@link IShoppingSaleQuestion.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "format": {
                "type": "string",
                "enum": [
                  "html",
                  "md",
                  "txt"
                ],
                "description": "Format of body.\n\nSame meaning with extension like `html`, `md`, `txt`."
              },
              "title": {
                "type": "string",
                "description": "Title of article."
              },
              "body": {
                "type": "string",
                "description": "Content body of article."
              },
              "files": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "File name, except extension.\n\nIf there's file `.gitignore`, then its name is an empty string.\n\n\n@maxLength 255"
                    },
                    "extension": {
                      "type": "string",
                      "nullable": true,
                      "description": "Extension.\n\nPossible to omit like `README` case.\n\n\n@minLength 1\n@maxLength 8"
                    },
                    "url": {
                      "type": "string",
                      "description": "URL path of the real file.\n\n\n@format uri\n@contentMediaType image/*"
                    }
                  },
                  "required": [
                    "name",
                    "extension",
                    "url"
                  ],
                  "description": "Current Type: {@link IAttachmentFile.ICreate}\n\n------------------------------\n\nDescription of the parent {@link IAttachmentFile} type:\n\n> Attachment File.\n> \n> Every attachment files that are managed in current system.\n> \n> For reference, it is possible to omit one of file {@link name}\n> or {@link extension} like `.gitignore` or `README` case, but not\n> possible to omit both of them."
                },
                "description": "List of attachment files."
              }
            },
            "required": [
              "format",
              "title",
              "body",
              "files"
            ],
            "description": "Update info of the question\n\n------------------------------\n\nDescription of the current {@link IBbsArticle.ICreate} type:\n\n> Creation information of the article."
          }
        },
        "required": [
          "saleId",
          "id",
          "body"
        ]
      },
      "description": "Update a question.\n\nUpdate a {@link IShoppingSaleQuestion question}'s content.\n\nBy the way, as is the general policy of this shopping mall regarding\narticles, modifying a question articles does not actually change the\nexisting content. Modified content is accumulated and recorded in the\nexisting article record as a new\n{@link IShoppingSaleQuestion.ISnapshot snapshot}. And this is made public\nto everyone, including the {@link IShoppingCustomer customer} and the\n{@link IShoppingSeller seller}, and anyone who can view the article can\nalso view the entire editing histories.\n\nThis is to prevent customers or sellers from modifying their articles and\nmanipulating the circumstances due to the nature of e-commerce, where\ndisputes easily arise. That is, to preserve evidence."
    },
    {
      "name": "shoppings_customers_sales_reviews_comments_update",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Belonged sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "inquiryId": {
            "type": "string",
            "description": " Belonged inquiry's {@link IShoppingSaleInquiry.id }\n\n\n@format uuid"
          },
          "id": {
            "type": "string",
            "description": " Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "format": {
                "type": "string",
                "enum": [
                  "html",
                  "md",
                  "txt"
                ],
                "description": "Format of body.\n\nSame meaning with extension like `html`, `md`, `txt`."
              },
              "body": {
                "type": "string",
                "description": "Content body of comment."
              },
              "files": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "File name, except extension.\n\nIf there's file `.gitignore`, then its name is an empty string.\n\n\n@maxLength 255"
                    },
                    "extension": {
                      "type": "string",
                      "nullable": true,
                      "description": "Extension.\n\nPossible to omit like `README` case.\n\n\n@minLength 1\n@maxLength 8"
                    },
                    "url": {
                      "type": "string",
                      "description": "URL path of the real file.\n\n\n@format uri\n@contentMediaType image/*"
                    }
                  },
                  "required": [
                    "name",
                    "extension",
                    "url"
                  ],
                  "description": "Current Type: {@link IAttachmentFile.ICreate}\n\n------------------------------\n\nDescription of the parent {@link IAttachmentFile} type:\n\n> Attachment File.\n> \n> Every attachment files that are managed in current system.\n> \n> For reference, it is possible to omit one of file {@link name}\n> or {@link extension} like `.gitignore` or `README` case, but not\n> possible to omit both of them."
                },
                "description": "List of attachment files."
              }
            },
            "required": [
              "format",
              "body",
              "files"
            ],
            "description": "Update info of the inquiry comment\n\n------------------------------\n\nDescription of the current {@link IShoppingSaleInquiryComment.ICreate} type:\n\n> Creation information of the comment.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSaleInquiryComment} type:\n\n> A comment written on an inquiry article.\n> \n> `IShoppingSaleInquiryComment` is a subtype entity of {@link IBbsArticleComment},\n> and is used when you want to communicate with multiple people about an\n> {@link IShoppingSaleInquiry inquiry} written by a\n> {@link IShoppingCustomer customer}.\n> \n> For reference, only related parties can write comments for\n> {@link IShoppingSeller sellers}, but there is no limit to\n> {@link IShoppingCustomer customers}. In other words, anyone customer can\n> freely write a comment, even if they are not the person who wrote the inquiry."
          }
        },
        "required": [
          "saleId",
          "inquiryId",
          "id",
          "body"
        ]
      },
      "description": "Update an inquiry comment.\n\nUpdate an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n\nBy the way, as is the general policy of this shopping mall regarding\ncomments, modifying a comment does not actually change the existing content.\nModified content is accumulated and recorded in the existing comment record\nas a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this\nis made public to everyone, who can read this inquiry comment.\n\nThis is to prevent customers or sellers from modifying their comments and\nmanipulating the circumstances due to the nature of e-commerce, where\ndisputes easily arise. That is, to preserve evidence."
    },
    {
      "name": "shoppings_customers_sales_reviews_update",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Belonged sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "id": {
            "type": "string",
            "description": " Target review's {@link IShoppingSaleReview.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "score": {
                "type": "number",
                "description": "Score of the review.\n\n\n@minimum 0\n@maximum 100"
              },
              "format": {
                "type": "string",
                "enum": [
                  "html",
                  "md",
                  "txt"
                ],
                "description": "Format of body.\n\nSame meaning with extension like `html`, `md`, `txt`."
              },
              "title": {
                "type": "string",
                "description": "Title of article."
              },
              "body": {
                "type": "string",
                "description": "Content body of article."
              },
              "files": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "File name, except extension.\n\nIf there's file `.gitignore`, then its name is an empty string.\n\n\n@maxLength 255"
                    },
                    "extension": {
                      "type": "string",
                      "nullable": true,
                      "description": "Extension.\n\nPossible to omit like `README` case.\n\n\n@minLength 1\n@maxLength 8"
                    },
                    "url": {
                      "type": "string",
                      "description": "URL path of the real file.\n\n\n@format uri\n@contentMediaType image/*"
                    }
                  },
                  "required": [
                    "name",
                    "extension",
                    "url"
                  ],
                  "description": "Current Type: {@link IAttachmentFile.ICreate}\n\n------------------------------\n\nDescription of the parent {@link IAttachmentFile} type:\n\n> Attachment File.\n> \n> Every attachment files that are managed in current system.\n> \n> For reference, it is possible to omit one of file {@link name}\n> or {@link extension} like `.gitignore` or `README` case, but not\n> possible to omit both of them."
                },
                "description": "List of attachment files."
              }
            },
            "required": [
              "score",
              "format",
              "title",
              "body",
              "files"
            ],
            "description": "Update info of the review\n\n------------------------------\n\nDescription of the current {@link IShoppingSaleReview.IUpdate} type:\n\n> Updating information of the review.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSaleReview} type:\n\n> Reviews for sale snapshots.\n> \n> `IShoppingSaleReview` is a subtype entity of {@link IShoppingSaleInquiry},\n> and is used when a {@link IShoppingCustomer customer} purchases a\n> {@link IShoppingSale sale} ({@link IShoppingSaleSnapshot snapshot} at the time)\n> registered by the {@link IShoppingSeller seller} as a product and leaves a\n> review and rating for it.\n> \n> For reference, `IShoppingSaleReview` and\n> {@link IShoppingOrderGod shopping_order_goods} have a logarithmic relationship\n> of N: 1, but this does not mean that customers can continue to write reviews\n> for the same product indefinitely. Wouldn't there be restrictions, such as\n> if you write a review once, you can write an additional review a month later?"
          }
        },
        "required": [
          "saleId",
          "id",
          "body"
        ]
      },
      "description": "Update a review.\n\nUpdadte a {@link IShoppingSaleReview review}'s content and score.\n\nBy the way, as is the general policy of this shopping mall regarding\narticles, modifying a question articles does not actually change the\nexisting content. Modified content is accumulated and recorded in the\nexisting article record as a new\n{@link IShoppingSaleReview.ISnapshot snapshot}. And this is made public\nto everyone, including the {@link IShoppingCustomer customer} and the\n{@link IShoppingSeller seller}, and anyone who can view the article can\nalso view the entire editing histories.\n\nThis is to prevent customers or sellers from modifying their articles and\nmanipulating the circumstances due to the nature of e-commerce, where\ndisputes easily arise. That is, to preserve evidence."
    },
    {
      "name": "shoppings_customers_sales_snapshots_index",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Target sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Requestion info of pagination\n\n------------------------------\n\nDescription of the current {@link IPage.IRequest} type:\n\n> Page request data"
          }
        },
        "required": [
          "saleId",
          "body"
        ]
      },
      "description": "List up every snapshots.\n\nWhenever {@link IShoppingSeller seller} updates a\n{@link IShoppingSale sale}, the sale record is not updated but a new\n{@link IShoppingSaleSnapshot snapshot} record is created to keep the\nintegrity of the sale history. This API function is for listing up\nsuch snapshot records.\n\nAlso, as you can see from the return type, returned snapshots are\nsummarized, not detailed. If you want to get the detailed information\nof a snapshot, use {@link at} or {@link flipo} function for each snapshot.\n\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\naccess to the your own {@link IShoppingSale sale}'s snapshots. Otherwise,\nyou can access to every snapshots of the sales even though the sale has\nbeen closed or suspended."
    },
    {
      "name": "shoppings_customers_systematic_channels_categories_index",
      "parameters": {
        "type": "object",
        "properties": {
          "channelCode": {
            "type": "string",
            "description": " Belonged channel's {@link IShoppingChannel.code }"
          }
        },
        "required": [
          "channelCode"
        ]
      },
      "description": "List up every categories with children records.\n\nList up every {@link IShoppingChannelCategory.IHierarchical categories}\nof a {@link IShoppingChannel channel} with pagination. Returned categories\ncontain children categories, too.\n\nIf you want, you can limit the result by configuring\n{@link IShoppingChannelCategory.IRequest.search search condition} in the\nrequest body. Also, it is possible to customize sequence order of records\nby configuring {@link IShoppingChannelCategory.IRequest.sort sort condition}."
    },
    {
      "name": "shoppings_customers_systematic_channels_categories_at",
      "parameters": {
        "type": "object",
        "properties": {
          "channelCode": {
            "type": "string",
            "description": " Belonged channel's {@link IShoppingChannel.code }"
          },
          "id": {
            "type": "string",
            "description": " Target category's {@link IShoppingChannelCategory.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "channelCode",
          "id"
        ]
      },
      "description": "Get a category info.\n\nGet a detailed {@link IShoppingChannelCategory category} information.\n\nReturned category contains hierarchical children categories, and also\ncontains the recursive parent categories, too."
    },
    {
      "name": "shoppings_customers_systematic_channels_categories_invert",
      "parameters": {
        "type": "object",
        "properties": {
          "channelCode": {
            "type": "string",
            "description": " Belonged channel's {@link IShoppingChannel.code }"
          },
          "id": {
            "type": "string",
            "description": " Target category's {@link IShoppingChannelCategory.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "channelCode",
          "id"
        ]
      },
      "description": "Get a category info of inverted.\n\nGet a inverted {@link IShoppingChannelCategory.IInvert category} information.\n\nReturned category contains the recursive parent categories, but not contains\nthe hierarchical children categories."
    },
    {
      "name": "shoppings_customers_systematic_channels_index",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "search": {
                "type": "object",
                "properties": {
                  "code": {
                    "type": "string",
                    "nullable": true
                  },
                  "name": {
                    "type": "string",
                    "nullable": true
                  }
                },
                "required": [],
                "nullable": true
              },
              "sort": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "-channel.code",
                    "-channel.name",
                    "-channel.created_at",
                    "+channel.code",
                    "+channel.name",
                    "+channel.created_at"
                  ]
                },
                "nullable": true
              },
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Request info of pagination, searching and sorting\n\n------------------------------\n\nDescription of the current {@link IShoppingChannel.IRequest} type:\n\n> Request of the channels with pagination and searching/sorting options.\n\n------------------------------\n\nDescription of the parent {@link IShoppingChannel} type:\n\n> Channel information.\n> \n> `IShoppingChannel` is a concept that shapes the distribution channel in the\n> market. Therefore, the difference in the channel in this e-commerce system\n> means that it is another site or application.\n> \n> By the way, if your shopping mall system requires only one channel, then\n> just use only one. This concept is designed to be expandable in the future."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "List up every channels.\n\nList up every {@link IShoppingChannel channels} with pagination.\n\nIf you want, you can limit the result by configuring\n{@link IShoppingChannel.IRequest.search search condition} in the request\nbody. Also, it is possible to customize sequence order of records by\nconfiguring {@link IShoppingChannel.IRequest.sort sort condition}."
    },
    {
      "name": "shoppings_customers_systematic_channels_hierarchical",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "search": {
                "type": "object",
                "properties": {
                  "code": {
                    "type": "string",
                    "nullable": true
                  },
                  "name": {
                    "type": "string",
                    "nullable": true
                  }
                },
                "required": [],
                "nullable": true
              },
              "sort": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "-channel.code",
                    "-channel.name",
                    "-channel.created_at",
                    "+channel.code",
                    "+channel.name",
                    "+channel.created_at"
                  ]
                },
                "nullable": true
              },
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Request info of pagination, searching and sorting\n\n------------------------------\n\nDescription of the current {@link IShoppingChannel.IRequest} type:\n\n> Request of the channels with pagination and searching/sorting options.\n\n------------------------------\n\nDescription of the parent {@link IShoppingChannel} type:\n\n> Channel information.\n> \n> `IShoppingChannel` is a concept that shapes the distribution channel in the\n> market. Therefore, the difference in the channel in this e-commerce system\n> means that it is another site or application.\n> \n> By the way, if your shopping mall system requires only one channel, then\n> just use only one. This concept is designed to be expandable in the future."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "List up every channels with nested categories.\n\nList up every {@link IShoppingChannel.IHierarchical channels} with\n{@link IPage pagination}. Returned channels contain nested hierarchical\n{@link IShoppingChannelCategory.IHierarchical categories}.\n\nIf you want, you can limit the result by configuring\n{@link IShoppingChannel.IRequest.search search condition} in the request\nbody. Also, it is possible to customize sequence order of records by\nconfiguring {@link IShoppingChannel.IRequest.sort sort condition}."
    },
    {
      "name": "shoppings_customers_systematic_channels_at",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target channel's {@link IShoppingChannel.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Get a channel info.\n\nGet a detailed {@link IShoppingChannel.IHierarchical channel} information.\n\nReturned channel instance also contains the nested\n{@link IShoppingChannelCategory.IHierarchical hierarchical category}\ninformation."
    },
    {
      "name": "shoppings_customers_systematic_channels_get",
      "parameters": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "description": " Target channel's {@link IShoppingChannel.code }"
          }
        },
        "required": [
          "code"
        ]
      },
      "description": "Get a channel info by its code.\n\nGet a detailed {@link IShoppingChannel.IHierarchical channel} information\nby its code.\n\nReturned channel instance also contains the nested\n{@link IShoppingChannelCategory.IHierarchical hierarchical category}\ninformation."
    },
    {
      "name": "shoppings_customers_systematic_sections_index",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "search": {
                "type": "object",
                "properties": {
                  "code": {
                    "type": "string",
                    "nullable": true
                  },
                  "name": {
                    "type": "string",
                    "nullable": true
                  }
                },
                "required": [],
                "nullable": true
              },
              "sort": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "-section.code",
                    "-section.name",
                    "-section.created_at",
                    "+section.code",
                    "+section.name",
                    "+section.created_at"
                  ]
                },
                "nullable": true
              },
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Request info of pagination, searching and sorting\n\n------------------------------\n\nDescription of the current {@link IShoppingSection.IRequest} type:\n\n> Request of the sections with pagination and searching/sorting options.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSection} type:\n\n> Section information.\n> \n> `IShoppingSection` is a concept that refers to the spatial information of\n> the market.\n> \n> If we compare the section mentioned here to the offline market, it means a\n> spatially separated area within the store, such as the \"fruit corner\" or\n> \"butcher corner\". Therefore, in the {@link IShoppingSale sale} entity, it is\n> not possible to classify multiple sections simultaneously, but only one section\n> can be classified.\n> \n> By the way, if your shopping mall system requires only one section, then just\n> use only one. This concept is designed to be expandable in the future."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "List up every sections.\n\nList up every {@link IShoppingSection sections} with pagination.\n\nIf you want, you can limit the result by configuring\n{@link IShoppingSection.IRequest.search search condition} in the request\nbody. Also, it is possible to customize sequence order of records by\nconfiguring {@link IShoppingSection.IRequest.sort sort condition}."
    },
    {
      "name": "shoppings_customers_systematic_sections_at",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target section's {@link IShoppingSection.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Get a section info.\n\nGet a detailed {@link IShoppingSection section} information."
    },
    {
      "name": "shoppings_customers_systematic_sections_get",
      "parameters": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "description": " Target section's {@link IShoppingSection.code }"
          }
        },
        "required": [
          "code"
        ]
      },
      "description": "Get a section info by its code.\n\nGet a detailed {@link IShoppingSection section} information by its code."
    },
    {
      "name": "shoppings_sellers_deliveries_create",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "pieces": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "publish_id": {
                      "type": "string",
                      "description": "Target order's {@link IShoppingOrderPublish.id}.\n\n\n@format uuid"
                    },
                    "good_id": {
                      "type": "string",
                      "description": "Target good's {@link IShoppingOrderGood.id}.\n\n\n@format uuid"
                    },
                    "stock_id": {
                      "type": "string",
                      "description": "Target stock's {@link IShoppingSaleUnitStock.id}.\n\n\n@format uuid"
                    },
                    "quantity": {
                      "type": "number",
                      "description": "Quantity of the stock.\n\nIt can be precision value to express split shipping.\n\n\n@minimum 0"
                    }
                  },
                  "required": [
                    "publish_id",
                    "good_id",
                    "stock_id",
                    "quantity"
                  ],
                  "description": "Description of the current {@link IShoppingDeliveryPiece.ICreate} type:\n\n> Creation information of the delivery piece.\n\n------------------------------\n\nDescription of the parent {@link IShoppingDeliveryPiece} type:\n\n> Which stocks are delivered.\n> \n> `IShoppingDeliveryPiece` is a subsidiary entity of {@link IShoppingDelivery},\n> describing how much quantity is delivered for each\n> {@link IShoppingSaleUnitStock stock} in {@link IShoppingOrder}.\n> \n> For reference, as an order can be delivered in multiple times due to volume\n> or weight problem, it is possible to have multiple `IShoppingDeliveryPiece`\n> records for a single stock."
                },
                "description": "List of pieces of the delivery.\n\n\n@minItems 1"
              },
              "journeys": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": [
                        "preparing",
                        "manufacturing",
                        "shipping",
                        "delivering"
                      ],
                      "description": "Type of journey.\n\n- preparing\n- manufacturing\n- shipping\n- delivering"
                    },
                    "title": {
                      "type": "string",
                      "nullable": true,
                      "description": "Title of journey."
                    },
                    "description": {
                      "type": "string",
                      "nullable": true,
                      "description": "Description of journey."
                    },
                    "started_at": {
                      "type": "string",
                      "nullable": true,
                      "description": "Start time of the journey.\n\n\n@format date-time"
                    },
                    "completed_at": {
                      "type": "string",
                      "nullable": true,
                      "description": "Completion time of the journey.\n\n\n@format date-time"
                    }
                  },
                  "required": [
                    "type",
                    "title",
                    "description",
                    "started_at",
                    "completed_at"
                  ],
                  "description": "Description of the current {@link IShoppingDeliveryJourney.ICreate} type:\n\n> Creation information of the delivery journey.\n\n------------------------------\n\nDescription of the parent {@link IShoppingDeliveryJourney} type:\n\n> Journey of delivery.\n> \n> `IShoppingDeliveryJourney` is a subsidiary entity of {@link IShoppingDelivery},\n> describing each journey of the delivery. For reference, the word journey\n> means each step of the delivery process, such as preparing, shipping, and\n> delivering {@link IShoppingOrderGood goods} to the\n> {@link IShoppingCustomer customer}."
                },
                "description": "List of journeys of the delivery.\n\nThis is initial data, and it is also possible to accumulate journey data\nafter the delivery creation."
              },
              "shippers": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "company": {
                      "type": "string",
                      "nullable": true
                    },
                    "name": {
                      "type": "string"
                    },
                    "mobile": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "company",
                    "name",
                    "mobile"
                  ],
                  "description": "Current Type: {@link IShoppingDeliveryShipper.ICreate}"
                },
                "description": "List of shippers of the delivery."
              }
            },
            "required": [
              "pieces",
              "journeys",
              "shippers"
            ],
            "description": "Creation info of delivery\n\n------------------------------\n\nDescription of the current {@link IShoppingDelivery.ICreate} type:\n\n> Creation information of the delivery.\n\n------------------------------\n\nDescription of the parent {@link IShoppingDelivery} type:\n\n> Delivery information.\n> \n> When delivering {@link IShoppingOrderGood goods} to\n> {@link IShoppingCustomer customer}, {@link IShoppingSeller seller} can deliver\n> multiple {@link IShoppingSaleUnitStock stocks}, goods at once. Also, it is\n> possible to deliver a stock or good in multiple times due to physical restriction\n> like volume or weight problem.\n> \n> As you can see from above, the relationship between delivery with\n> {@link IShoppingOrder order} (or {@link IShoppingOrderGood good}) is not 1: 1 or\n> N: 1, but M: N. Entity `IShoppingDelivery` has been designed to represent such\n> relationship, by referencing target stocks or goods through subsidiary entity\n> {@link IShoppingDeliveryPiece}.\n> \n> Also, delivery does not end with only one step. It has multiple processes like\n> manufacturing, planning, shipping and delivering. Those steps are represented by\n> another subsidiary entity {@link IShoppingDeliveryJourney}."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "Create a delivery.\n\nCreate a {@link IShoppingDelivery delivery} record targeting\n{@link IShoppingOrder orders}, their {@link IShoppingOrderGood goods} and\n{@link IShoppingSaleUnitStock stocks} ({@link IShoppingDeliveryPiece}) with\n{@link IShoppingDeliveryJourney journeys} and\n{@link IShoppingDeliveryShipper shippers} info.\n\nNote that, composition of the {@link IShoppingDeliveryPiece} must not over\nthe required. To identify which pieces are required, recommend to call\nthe {@link incompletes} function with target orders'\n{@link IShoppingOrderPublish.id}s before calling this one."
    },
    {
      "name": "shoppings_sellers_deliveries_incompletes",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "publish_ids": {
                "type": "array",
                "items": {
                  "type": "string",
                  "description": "@format uuid"
                }
              }
            },
            "required": [
              "publish_ids"
            ],
            "description": "List of target orders' \n\n------------------------------\n\nCurrent Type: {@link IShoppingDeliveryPiece.IRequest}\n\n------------------------------\n\nDescription of the parent {@link IShoppingDeliveryPiece} type:\n\n> Which stocks are delivered.\n> \n> `IShoppingDeliveryPiece` is a subsidiary entity of {@link IShoppingDelivery},\n> describing how much quantity is delivered for each\n> {@link IShoppingSaleUnitStock stock} in {@link IShoppingOrder}.\n> \n> For reference, as an order can be delivered in multiple times due to volume\n> or weight problem, it is possible to have multiple `IShoppingDeliveryPiece`\n> records for a single stock."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "Get list of incomplete pieces.\n\nGet list of {@link IShoppingDeliveryPiece incomplete pieces} of target\norders' {@link IShoppingOrderPublish.id}s.\n\nIf you specify target orders' publish IDs, then this function returns\nincompleted pieces of the orders with computation as an Array of\n{@link IShoppingDeliveryPiece.ICreate} type.\n\nYou can utillize the result to make a huge {@link IShoppingDelivery delivery}\nfor integrated delivering, and also possible to make multiple deliveries for\nsplit delivering."
    },
    {
      "name": "shoppings_sellers_deliveries_journeys_create",
      "parameters": {
        "type": "object",
        "properties": {
          "deliveryId": {
            "type": "string",
            "description": " Belonged delivery's {@link IShoppingDelivery.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "preparing",
                  "manufacturing",
                  "shipping",
                  "delivering"
                ],
                "description": "Type of journey.\n\n- preparing\n- manufacturing\n- shipping\n- delivering"
              },
              "title": {
                "type": "string",
                "nullable": true,
                "description": "Title of journey."
              },
              "description": {
                "type": "string",
                "nullable": true,
                "description": "Description of journey."
              },
              "started_at": {
                "type": "string",
                "nullable": true,
                "description": "Start time of the journey.\n\n\n@format date-time"
              },
              "completed_at": {
                "type": "string",
                "nullable": true,
                "description": "Completion time of the journey.\n\n\n@format date-time"
              }
            },
            "required": [
              "type",
              "title",
              "description",
              "started_at",
              "completed_at"
            ],
            "description": "Creation info of the journey\n\n------------------------------\n\nDescription of the current {@link IShoppingDeliveryJourney.ICreate} type:\n\n> Creation information of the delivery journey.\n\n------------------------------\n\nDescription of the parent {@link IShoppingDeliveryJourney} type:\n\n> Journey of delivery.\n> \n> `IShoppingDeliveryJourney` is a subsidiary entity of {@link IShoppingDelivery},\n> describing each journey of the delivery. For reference, the word journey\n> means each step of the delivery process, such as preparing, shipping, and\n> delivering {@link IShoppingOrderGood goods} to the\n> {@link IShoppingCustomer customer}."
          }
        },
        "required": [
          "deliveryId",
          "body"
        ]
      },
      "description": "Create a new journey.\n\nCreate a new {@link IShoppingDeliveryJourney journey} of the\n{@link IShoppingDelivery delivery}.\n\nThis action may change the related {@link IShoppingOrderGood.state}.\nAlso, if the target journey's type is \"delivering\", whether the property\n{@link IShoppingDeliveryJourney.completed_at} is null or not affects to\nthe related goods' states. If the property is not null, the state becomes\n\"arrived\". Otherwise, the state becomes \"delivering\"."
    },
    {
      "name": "shoppings_sellers_deliveries_journeys_complete",
      "parameters": {
        "type": "object",
        "properties": {
          "deliveryId": {
            "type": "string",
            "description": " Belonged delivery's {@link IShoppingDelivery.id }\n\n\n@format uuid"
          },
          "id": {
            "type": "string",
            "description": " Target journey's {@link IShoppingDeliveryJourney.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "completed_at": {
                "type": "string",
                "nullable": true,
                "description": "Completion time of the journey.\n\n\n@format date-time"
              }
            },
            "required": [
              "completed_at"
            ],
            "description": "Completion time of the journey\n\n------------------------------\n\nDescription of the current {@link IShoppingDeliveryJourney.IComplete} type:\n\n> Completion information of the delivery journey.\n\n------------------------------\n\nDescription of the parent {@link IShoppingDeliveryJourney} type:\n\n> Journey of delivery.\n> \n> `IShoppingDeliveryJourney` is a subsidiary entity of {@link IShoppingDelivery},\n> describing each journey of the delivery. For reference, the word journey\n> means each step of the delivery process, such as preparing, shipping, and\n> delivering {@link IShoppingOrderGood goods} to the\n> {@link IShoppingCustomer customer}."
          }
        },
        "required": [
          "deliveryId",
          "id",
          "body"
        ]
      },
      "description": "Complete a journey.\n\nComplete a {@link IShoppingDeliveryJourney journey} of the\n{@link IShoppingDelivery delivery}. In other words, fills the\n{@link IShoppingDeliveryJourney.completed_at} property with current time.\n\nIf the target journey's type is \"delivering\", this action may change\nthe related {@link IShoppingOrderGood.state goods' states} to be \"arrived\"."
    },
    {
      "name": "shoppings_sellers_deliveries_journeys_erase",
      "parameters": {
        "type": "object",
        "properties": {
          "deliveryId": {
            "type": "string",
            "description": " Belonged delivery's {@link IShoppingDelivery.id }\n\n\n@format uuid"
          },
          "id": {
            "type": "string",
            "description": " Target journey's {@link IShoppingDeliveryJourney.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "deliveryId",
          "id"
        ]
      },
      "description": "Erase a journey.\n\nErase a {@link IShoppingDeliveryJourney journey} of the\n{@link IShoppingDelivery delivery}.\n\nIf erasing journey is the last one of the belonged delivery, this action\nmay change the related {@link IShoppingOrderGood.state}. By erasing the last\njourney, the state rolls back to the previous."
    },
    {
      "name": "shoppings_sellers_deliveries_shippers_create",
      "parameters": {
        "type": "object",
        "properties": {
          "deliveryId": {
            "type": "string",
            "description": " Belonged delivery's {@link IShoppingDelivery.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "company": {
                "type": "string",
                "nullable": true
              },
              "name": {
                "type": "string"
              },
              "mobile": {
                "type": "string"
              }
            },
            "required": [
              "company",
              "name",
              "mobile"
            ],
            "description": "Creation info of the shipper\n\n------------------------------\n\nCurrent Type: {@link IShoppingDeliveryShipper.ICreate}"
          }
        },
        "required": [
          "deliveryId",
          "body"
        ]
      },
      "description": "Create a new shipper.\n\nCreate a new {@link IShoppingDeliveryShipper shipper} of the\n{@link IShoppingDelivery delivery}.\n\nThis action does not affect to the related {@link IShoppingOrder orders} or\n{@link IShoppingOrderGood goods} like {@link IShoppingDeliveryJourney}\nor {@link IShoppingDeliveryPiece} case, but just informs to the\n{@link IShoppingCustomer customer}."
    },
    {
      "name": "shoppings_sellers_coupons_erase",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target coupon's {@link IShoppingCoupon.id }"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Erase a coupon.\n\nErase a {@link IShoppingCoupon coupon} with given ID.\n\nFor reference, if there're some {@link IShoppingCouponTicket tickets}\nwhich are already issued from the target coupon, they would not be affected.\nThose tickets are still valid until their expration time."
    },
    {
      "name": "shoppings_sellers_sales_index",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "sort": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "-seller.created_at",
                    "-seller.goods.payments.real",
                    "-seller.goods.publish_count",
                    "-seller.reviews.average",
                    "-seller.reviews.count",
                    "-goods.publish_count",
                    "-goods.payments.real",
                    "-reviews.average",
                    "-reviews.count",
                    "-sale.created_at",
                    "-sale.updated_at",
                    "-sale.opened_at",
                    "-sale.closed_at",
                    "-sale.content.title",
                    "-sale.price_range.lowest.real",
                    "-sale.price_range.highest.real",
                    "+seller.created_at",
                    "+seller.goods.payments.real",
                    "+seller.goods.publish_count",
                    "+seller.reviews.average",
                    "+seller.reviews.count",
                    "+goods.publish_count",
                    "+goods.payments.real",
                    "+reviews.average",
                    "+reviews.count",
                    "+sale.created_at",
                    "+sale.updated_at",
                    "+sale.opened_at",
                    "+sale.closed_at",
                    "+sale.content.title",
                    "+sale.price_range.lowest.real",
                    "+sale.price_range.highest.real"
                  ]
                },
                "nullable": true,
                "description": "Sorting conditions."
              },
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Request info of pagination, searching and sorting\n\n------------------------------\n\nDescription of the current {@link IShoppingSale.IRequest} type:\n\n> Request of summarized sales with pagination and searching/sorting options.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSale} type:\n\n> Seller sales products.\n> \n> `IShoppingSale` is an entity that embodies \"product sales\" (sales)\n> information registered by the {@link ISoppingSeller seller}. And the main\n> information of the sale is recorded in the sub {@link IShoppingSaleSnapshot},\n> not in the main `IShoppingSale`. When a seller changes a previously registered\n> item, the existing `IShoppingSale` record is not changed, but a new\n> {@link IShoppingSaleSnapshot snapshot} record be created.\n> \n> This is to preserve the {@link IShoppingCustomer customer}'s\n> {@link IShoppingOrder purchase history} flawlessly after the customer\n> purchases a specific item, even if the seller changes the components or\n> price of the item. It is also intended to support sellers in so-called A/B\n> testing, which involves changing components or prices and measuring the\n> performance in each case."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "List up every summarized sales.\n\nList up every {@link IShoppingSale.ISummary summarized sales}.\n\nAs you can see, returned sales are summarized, not detailed. It does not\ncontain the SKU (Stock Keeping Unit) information represented by the\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\nIf you want to get such detailed information of a sale, use\n`GET /shoppings/customers/sales/{id}` operation for each sale.\n\n> If you're an A.I. chatbot, and the user wants to buy or compose\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\n> to the target sale to get detailed SKU information about the sale.\n> It needs to be run at least once for the next steps."
    },
    {
      "name": "shoppings_sellers_sales_open",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "opened_at": {
                "type": "string",
                "nullable": true,
                "description": "Opening time of the sale.\n\n\n@format date-time"
              },
              "closed_at": {
                "type": "string",
                "nullable": true,
                "description": "Closing time of the sale.\n\nIf this value is `null`, the sale be continued forever.\n\n\n@format date-time"
              }
            },
            "required": [
              "opened_at",
              "closed_at"
            ],
            "description": "New opening and closing time\n\n------------------------------\n\nDescription of the current {@link IShoppingSale.IUpdateOpeningTime} type:\n\n> Update opening time information of sale.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSale} type:\n\n> Seller sales products.\n> \n> `IShoppingSale` is an entity that embodies \"product sales\" (sales)\n> information registered by the {@link ISoppingSeller seller}. And the main\n> information of the sale is recorded in the sub {@link IShoppingSaleSnapshot},\n> not in the main `IShoppingSale`. When a seller changes a previously registered\n> item, the existing `IShoppingSale` record is not changed, but a new\n> {@link IShoppingSaleSnapshot snapshot} record be created.\n> \n> This is to preserve the {@link IShoppingCustomer customer}'s\n> {@link IShoppingOrder purchase history} flawlessly after the customer\n> purchases a specific item, even if the seller changes the components or\n> price of the item. It is also intended to support sellers in so-called A/B\n> testing, which involves changing components or prices and measuring the\n> performance in each case."
          }
        },
        "required": [
          "id",
          "body"
        ]
      },
      "description": "Change opening and closing time of a sale.\n\nUpdate a {@link IShoppingSale sale}'s opening and closing time.\n\nBy the way, if the sale still be opened or closed, it is not possible to\nchange the opening time. In contrary, if the sale already had been opened\nbut still not closed, it is possible to change the closing time.\n\nOf course, if closing time is less than opening time or not,\n428 unprocessable entity error would be thrown."
    },
    {
      "name": "shoppings_sellers_sales_pause",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Pause a sale.\n\nPause a {@link IShoppingSale sale} from {@link open opened} state.\nTherefore, the sale can not be operated again until it be\n{@link restore restored}. By the way, {@link IShoppingCustomer customer}\nstill can sale from the {@link index} and {@link at} API endpoints, but\n\"paused\" label would be attached.\n\nAlso, customer no more can put into the shopping cart, either.\nEven the sale already had been put into the shopping cart, the\n{@link IShoppingCartCommodity commodity} will not be listed on the\nshopping cart. Also, it is not possible to applying an\n{@link IShoppingOrder order} with the paused sale's commodity, either.\n\nBy the way, if the sale already had been applied to an order, the order\ncan be {@link IShoppingOrderPublish published} and\n{@link IShoppingSeller seller} must {@link IShoppingDelivery deliver} the\ngood to the customer."
    },
    {
      "name": "shoppings_sellers_sales_suspend",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Suspend a sale.\n\nSuspend a {@link IShoppingSale sale} from {@link open opened} state.\nTherefore, the sale can not be operated again until it be\n{@link restore restored} and {@link IShoppingCustomer customer} cannot\nsee the sale from the {@link index} and {@link at} API.\n\nAlso, customer no more can put into the shopping cart, either.\nEven the sale already had been put into the shopping cart, the\n{@link IShoppingCartCommodity commodity} will not be listed on the\nshopping cart. Also, it is not possible to applying an\n{@link IShoppingOrder order} with the suspended sale's commodity, either.\n\nBy the way, if the sale already had been applied to an order, the order\ncan be {@link IShoppingOrderPublish published} and\n{@link IShoppingSeller seller} must {@link IShoppingDelivery deliver} the\ngood to the customer."
    },
    {
      "name": "shoppings_sellers_sales_restore",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Restore a sale\n\nRestore a {@link IShoppingSale sale} from {@link pause paused} or\n{@link suspend suspended} state\n\nTherefore the sale can be operated again if its\n{@link IShoppingSale.closed_at closing time} has not been reached.\nAlso, if a {@link IShoppingCustomer customer} had put the sale into the\nshopping cart when being paused or suspended, the\n{@link IShoppingCartCommodity commodity} will be listed again on the\nshopping cart."
    },
    {
      "name": "shoppings_sellers_sales_questions_answer_create",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Belonged sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "questionId": {
            "type": "string",
            "description": " Target question's {@link IShoppingSaleQuestion.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "format": {
                "type": "string",
                "enum": [
                  "html",
                  "md",
                  "txt"
                ],
                "description": "Format of body.\n\nSame meaning with extension like `html`, `md`, `txt`."
              },
              "title": {
                "type": "string",
                "description": "Title of article."
              },
              "body": {
                "type": "string",
                "description": "Content body of article."
              },
              "files": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "File name, except extension.\n\nIf there's file `.gitignore`, then its name is an empty string.\n\n\n@maxLength 255"
                    },
                    "extension": {
                      "type": "string",
                      "nullable": true,
                      "description": "Extension.\n\nPossible to omit like `README` case.\n\n\n@minLength 1\n@maxLength 8"
                    },
                    "url": {
                      "type": "string",
                      "description": "URL path of the real file.\n\n\n@format uri\n@contentMediaType image/*"
                    }
                  },
                  "required": [
                    "name",
                    "extension",
                    "url"
                  ],
                  "description": "Current Type: {@link IAttachmentFile.ICreate}\n\n------------------------------\n\nDescription of the parent {@link IAttachmentFile} type:\n\n> Attachment File.\n> \n> Every attachment files that are managed in current system.\n> \n> For reference, it is possible to omit one of file {@link name}\n> or {@link extension} like `.gitignore` or `README` case, but not\n> possible to omit both of them."
                },
                "description": "List of attachment files."
              }
            },
            "required": [
              "format",
              "title",
              "body",
              "files"
            ],
            "description": "Creation info of the answer article\n\n------------------------------\n\nDescription of the current {@link IBbsArticle.ICreate} type:\n\n> Creation information of the article."
          }
        },
        "required": [
          "saleId",
          "questionId",
          "body"
        ]
      },
      "description": "Write an answer article.\n\nWrite a formal {@link IShoppingSaleInquiryAnswer answer article} to a\nspecific {@link IShoppingSaleInquiry question article} written by a\n{@link IShoppingCustomer}.\n\nNote that, this is the formal answer that can be written only one per\na question article (but {@link update updatable}). Therefore, it needs to\nguide the {@link IShoppingSeller seller} to write it carefully.\n\nAlso, as seller can write {@link IShoppingSaleInquiryComment comments} to\nthe question article as many as he/she wants, it would be useful for\nadditional communication."
    },
    {
      "name": "shoppings_sellers_sales_questions_answer_update",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Belonged sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "questionId": {
            "type": "string",
            "description": " Target question's {@link IShoppingSaleQuestion.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "format": {
                "type": "string",
                "enum": [
                  "html",
                  "md",
                  "txt"
                ],
                "description": "Format of body.\n\nSame meaning with extension like `html`, `md`, `txt`."
              },
              "title": {
                "type": "string",
                "description": "Title of article."
              },
              "body": {
                "type": "string",
                "description": "Content body of article."
              },
              "files": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "File name, except extension.\n\nIf there's file `.gitignore`, then its name is an empty string.\n\n\n@maxLength 255"
                    },
                    "extension": {
                      "type": "string",
                      "nullable": true,
                      "description": "Extension.\n\nPossible to omit like `README` case.\n\n\n@minLength 1\n@maxLength 8"
                    },
                    "url": {
                      "type": "string",
                      "description": "URL path of the real file.\n\n\n@format uri\n@contentMediaType image/*"
                    }
                  },
                  "required": [
                    "name",
                    "extension",
                    "url"
                  ],
                  "description": "Current Type: {@link IAttachmentFile.ICreate}\n\n------------------------------\n\nDescription of the parent {@link IAttachmentFile} type:\n\n> Attachment File.\n> \n> Every attachment files that are managed in current system.\n> \n> For reference, it is possible to omit one of file {@link name}\n> or {@link extension} like `.gitignore` or `README` case, but not\n> possible to omit both of them."
                },
                "description": "List of attachment files."
              }
            },
            "required": [
              "format",
              "title",
              "body",
              "files"
            ],
            "description": "Update info of the answer article\n\n------------------------------\n\nDescription of the current {@link IBbsArticle.ICreate} type:\n\n> Creation information of the article."
          }
        },
        "required": [
          "saleId",
          "questionId",
          "body"
        ]
      },
      "description": "Update an answer article.\n\nUpdate a formal {@link IShoppingSaleInquiryAnswer answer article} to a\nspecific {@link IShoppingSaleInquiry question article} written by a\n{@link IShoppingCustomer}.\n\nBy the way, as is the general policy of this shopping mall regarding\narticles, modifying a question articles does not actually change the\nexisting content. Modified content is accumulated and recorded in the\nexisting article record as a new\n{@link IShoppingSaleInquiryAnswer.ISnapshot snapshot}. And this is made\npublic to everyone, including the {@link IShoppingCustomer customer} and the\n{@link IShoppingSeller seller}, and anyone who can view the article can\nalso view the entire editing histories.\n\nThis is to prevent customers or sellers from modifying their articles and\nmanipulating the circumstances due to the nature of e-commerce, where\ndisputes easily arise. That is, to preserve evidence."
    },
    {
      "name": "shoppings_sellers_sales_questions_comments_update",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Belonged sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "inquiryId": {
            "type": "string",
            "description": " Belonged inquiry's {@link IShoppingSaleInquiry.id }\n\n\n@format uuid"
          },
          "id": {
            "type": "string",
            "description": " Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "format": {
                "type": "string",
                "enum": [
                  "html",
                  "md",
                  "txt"
                ],
                "description": "Format of body.\n\nSame meaning with extension like `html`, `md`, `txt`."
              },
              "body": {
                "type": "string",
                "description": "Content body of comment."
              },
              "files": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "File name, except extension.\n\nIf there's file `.gitignore`, then its name is an empty string.\n\n\n@maxLength 255"
                    },
                    "extension": {
                      "type": "string",
                      "nullable": true,
                      "description": "Extension.\n\nPossible to omit like `README` case.\n\n\n@minLength 1\n@maxLength 8"
                    },
                    "url": {
                      "type": "string",
                      "description": "URL path of the real file.\n\n\n@format uri\n@contentMediaType image/*"
                    }
                  },
                  "required": [
                    "name",
                    "extension",
                    "url"
                  ],
                  "description": "Current Type: {@link IAttachmentFile.ICreate}\n\n------------------------------\n\nDescription of the parent {@link IAttachmentFile} type:\n\n> Attachment File.\n> \n> Every attachment files that are managed in current system.\n> \n> For reference, it is possible to omit one of file {@link name}\n> or {@link extension} like `.gitignore` or `README` case, but not\n> possible to omit both of them."
                },
                "description": "List of attachment files."
              }
            },
            "required": [
              "format",
              "body",
              "files"
            ],
            "description": "Update info of the inquiry comment\n\n------------------------------\n\nDescription of the current {@link IShoppingSaleInquiryComment.ICreate} type:\n\n> Creation information of the comment.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSaleInquiryComment} type:\n\n> A comment written on an inquiry article.\n> \n> `IShoppingSaleInquiryComment` is a subtype entity of {@link IBbsArticleComment},\n> and is used when you want to communicate with multiple people about an\n> {@link IShoppingSaleInquiry inquiry} written by a\n> {@link IShoppingCustomer customer}.\n> \n> For reference, only related parties can write comments for\n> {@link IShoppingSeller sellers}, but there is no limit to\n> {@link IShoppingCustomer customers}. In other words, anyone customer can\n> freely write a comment, even if they are not the person who wrote the inquiry."
          }
        },
        "required": [
          "saleId",
          "inquiryId",
          "id",
          "body"
        ]
      },
      "description": "Update an inquiry comment.\n\nUpdate an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n\nBy the way, as is the general policy of this shopping mall regarding\ncomments, modifying a comment does not actually change the existing content.\nModified content is accumulated and recorded in the existing comment record\nas a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this\nis made public to everyone, who can read this inquiry comment.\n\nThis is to prevent customers or sellers from modifying their comments and\nmanipulating the circumstances due to the nature of e-commerce, where\ndisputes easily arise. That is, to preserve evidence."
    },
    {
      "name": "shoppings_sellers_sales_reviews_answer_create",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Belonged sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "reviewId": {
            "type": "string",
            "description": " Target review's {@link IShoppingSaleReview.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "format": {
                "type": "string",
                "enum": [
                  "html",
                  "md",
                  "txt"
                ],
                "description": "Format of body.\n\nSame meaning with extension like `html`, `md`, `txt`."
              },
              "title": {
                "type": "string",
                "description": "Title of article."
              },
              "body": {
                "type": "string",
                "description": "Content body of article."
              },
              "files": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "File name, except extension.\n\nIf there's file `.gitignore`, then its name is an empty string.\n\n\n@maxLength 255"
                    },
                    "extension": {
                      "type": "string",
                      "nullable": true,
                      "description": "Extension.\n\nPossible to omit like `README` case.\n\n\n@minLength 1\n@maxLength 8"
                    },
                    "url": {
                      "type": "string",
                      "description": "URL path of the real file.\n\n\n@format uri\n@contentMediaType image/*"
                    }
                  },
                  "required": [
                    "name",
                    "extension",
                    "url"
                  ],
                  "description": "Current Type: {@link IAttachmentFile.ICreate}\n\n------------------------------\n\nDescription of the parent {@link IAttachmentFile} type:\n\n> Attachment File.\n> \n> Every attachment files that are managed in current system.\n> \n> For reference, it is possible to omit one of file {@link name}\n> or {@link extension} like `.gitignore` or `README` case, but not\n> possible to omit both of them."
                },
                "description": "List of attachment files."
              }
            },
            "required": [
              "format",
              "title",
              "body",
              "files"
            ],
            "description": "Creation info of the answer article\n\n------------------------------\n\nDescription of the current {@link IBbsArticle.ICreate} type:\n\n> Creation information of the article."
          }
        },
        "required": [
          "saleId",
          "reviewId",
          "body"
        ]
      },
      "description": "Write an answer article.\n\nWrite a formal {@link IShoppingSaleInquiryAnswer answer article} to a\nspecific {@link IShoppingSaleInquiry review article} written by a\n{@link IShoppingCustomer}.\n\nNote that, this is the formal answer that can be written only one per\na review article (but {@link update updatable}). Therefore, it needs to\nguide the {@link IShoppingSeller seller} to write it carefully.\n\nAlso, as seller can write {@link IShoppingSaleInquiryComment comments} to\nthe review article as many as he/she wants, it would be useful for\nadditional communication."
    },
    {
      "name": "shoppings_sellers_sales_reviews_answer_update",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Belonged sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "reviewId": {
            "type": "string",
            "description": " Target review's {@link IShoppingSaleReview.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "format": {
                "type": "string",
                "enum": [
                  "html",
                  "md",
                  "txt"
                ],
                "description": "Format of body.\n\nSame meaning with extension like `html`, `md`, `txt`."
              },
              "title": {
                "type": "string",
                "description": "Title of article."
              },
              "body": {
                "type": "string",
                "description": "Content body of article."
              },
              "files": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "File name, except extension.\n\nIf there's file `.gitignore`, then its name is an empty string.\n\n\n@maxLength 255"
                    },
                    "extension": {
                      "type": "string",
                      "nullable": true,
                      "description": "Extension.\n\nPossible to omit like `README` case.\n\n\n@minLength 1\n@maxLength 8"
                    },
                    "url": {
                      "type": "string",
                      "description": "URL path of the real file.\n\n\n@format uri\n@contentMediaType image/*"
                    }
                  },
                  "required": [
                    "name",
                    "extension",
                    "url"
                  ],
                  "description": "Current Type: {@link IAttachmentFile.ICreate}\n\n------------------------------\n\nDescription of the parent {@link IAttachmentFile} type:\n\n> Attachment File.\n> \n> Every attachment files that are managed in current system.\n> \n> For reference, it is possible to omit one of file {@link name}\n> or {@link extension} like `.gitignore` or `README` case, but not\n> possible to omit both of them."
                },
                "description": "List of attachment files."
              }
            },
            "required": [
              "format",
              "title",
              "body",
              "files"
            ],
            "description": "Update info of the answer article\n\n------------------------------\n\nDescription of the current {@link IBbsArticle.ICreate} type:\n\n> Creation information of the article."
          }
        },
        "required": [
          "saleId",
          "reviewId",
          "body"
        ]
      },
      "description": "Update an answer article.\n\nUpdate a formal {@link IShoppingSaleInquiryAnswer answer article} to a\nspecific {@link IShoppingSaleInquiry review article} written by a\n{@link IShoppingCustomer}.\n\nBy the way, as is the general policy of this shopping mall regarding\narticles, modifying a review articles does not actually change the\nexisting content. Modified content is accumulated and recorded in the\nexisting article record as a new\n{@link IShoppingSaleInquiryAnswer.ISnapshot snapshot}. And this is made\npublic to everyone, including the {@link IShoppingCustomer customer} and the\n{@link IShoppingSeller seller}, and anyone who can view the article can\nalso view the entire editing histories.\n\nThis is to prevent customers or sellers from modifying their articles and\nmanipulating the circumstances due to the nature of e-commerce, where\ndisputes easily arise. That is, to preserve evidence."
    },
    {
      "name": "shoppings_sellers_sales_reviews_comments_update",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Belonged sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "inquiryId": {
            "type": "string",
            "description": " Belonged inquiry's {@link IShoppingSaleInquiry.id }\n\n\n@format uuid"
          },
          "id": {
            "type": "string",
            "description": " Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "format": {
                "type": "string",
                "enum": [
                  "html",
                  "md",
                  "txt"
                ],
                "description": "Format of body.\n\nSame meaning with extension like `html`, `md`, `txt`."
              },
              "body": {
                "type": "string",
                "description": "Content body of comment."
              },
              "files": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "File name, except extension.\n\nIf there's file `.gitignore`, then its name is an empty string.\n\n\n@maxLength 255"
                    },
                    "extension": {
                      "type": "string",
                      "nullable": true,
                      "description": "Extension.\n\nPossible to omit like `README` case.\n\n\n@minLength 1\n@maxLength 8"
                    },
                    "url": {
                      "type": "string",
                      "description": "URL path of the real file.\n\n\n@format uri\n@contentMediaType image/*"
                    }
                  },
                  "required": [
                    "name",
                    "extension",
                    "url"
                  ],
                  "description": "Current Type: {@link IAttachmentFile.ICreate}\n\n------------------------------\n\nDescription of the parent {@link IAttachmentFile} type:\n\n> Attachment File.\n> \n> Every attachment files that are managed in current system.\n> \n> For reference, it is possible to omit one of file {@link name}\n> or {@link extension} like `.gitignore` or `README` case, but not\n> possible to omit both of them."
                },
                "description": "List of attachment files."
              }
            },
            "required": [
              "format",
              "body",
              "files"
            ],
            "description": "Update info of the inquiry comment\n\n------------------------------\n\nDescription of the current {@link IShoppingSaleInquiryComment.ICreate} type:\n\n> Creation information of the comment.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSaleInquiryComment} type:\n\n> A comment written on an inquiry article.\n> \n> `IShoppingSaleInquiryComment` is a subtype entity of {@link IBbsArticleComment},\n> and is used when you want to communicate with multiple people about an\n> {@link IShoppingSaleInquiry inquiry} written by a\n> {@link IShoppingCustomer customer}.\n> \n> For reference, only related parties can write comments for\n> {@link IShoppingSeller sellers}, but there is no limit to\n> {@link IShoppingCustomer customers}. In other words, anyone customer can\n> freely write a comment, even if they are not the person who wrote the inquiry."
          }
        },
        "required": [
          "saleId",
          "inquiryId",
          "id",
          "body"
        ]
      },
      "description": "Update an inquiry comment.\n\nUpdate an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n\nBy the way, as is the general policy of this shopping mall regarding\ncomments, modifying a comment does not actually change the existing content.\nModified content is accumulated and recorded in the existing comment record\nas a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this\nis made public to everyone, who can read this inquiry comment.\n\nThis is to prevent customers or sellers from modifying their comments and\nmanipulating the circumstances due to the nature of e-commerce, where\ndisputes easily arise. That is, to preserve evidence."
    },
    {
      "name": "shoppings_sellers_sales_snapshots_index",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Target sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Requestion info of pagination\n\n------------------------------\n\nDescription of the current {@link IPage.IRequest} type:\n\n> Page request data"
          }
        },
        "required": [
          "saleId",
          "body"
        ]
      },
      "description": "List up every snapshots.\n\nWhenever {@link IShoppingSeller seller} updates a\n{@link IShoppingSale sale}, the sale record is not updated but a new\n{@link IShoppingSaleSnapshot snapshot} record is created to keep the\nintegrity of the sale history. This API function is for listing up\nsuch snapshot records.\n\nAlso, as you can see from the return type, returned snapshots are\nsummarized, not detailed. If you want to get the detailed information\nof a snapshot, use {@link at} or {@link flipo} function for each snapshot.\n\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\naccess to the your own {@link IShoppingSale sale}'s snapshots. Otherwise,\nyou can access to every snapshots of the sales even though the sale has\nbeen closed or suspended."
    },
    {
      "name": "shoppings_sellers_sales_units_stocks_supplements_create",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Belonged sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "unitId": {
            "type": "string",
            "description": " Belonged unit's {@link IShoppingSaleUnit.id }\n\n\n@format uuid"
          },
          "stockId": {
            "type": "string",
            "description": " Target stock's {@link IShoppingSaleUnitStock.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "value": {
                "type": "integer",
                "description": "Supplemented quantity.\n\n\n@minimum 0"
              }
            },
            "required": [
              "value"
            ],
            "description": "Create info of the supplement\n\n------------------------------\n\nDescription of the current {@link IShoppingSaleUnitStockSupplement.ICreate} type:\n\n> Creation information of the supplement.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSaleUnitStockSupplement} type:\n\n> Supplementation of inventory quantity of stock.\n> \n> You know what? If a {@link IShoppingSaleUnitStock stock} has been sold over\n> its {@link IShoppingSaleUnitStock.ICreate.quantity initial inventory quantity},\n> the stock can't be sold anymore, because of out of stock. In that case, how the\n> {@link IShoppingSeller} should do?\n> \n> When the sotck is sold out, seller can supplement the inventory record by\n> registering this `IShoppingSaleUnitStockSupplement` record. Right, this\n> `IShoppingSaleUnitStockSupplement` is an entity that embodies the\n> supplementation of the inventory quantity of the belonged stock."
          }
        },
        "required": [
          "saleId",
          "unitId",
          "stockId",
          "body"
        ]
      },
      "description": "Create a supplement.\n\nCreate a {@link IShoppingSaleUnitStockSupplement supplement history} of a\nspecific {@link IShoppingSaleUnitStock stock}.\n\nTherefore, {@link IShoppingSaleUnitStockInventory.income inventory} of the\ntarget stock will be increased by the\n{@link IShoppingSaleUnitStockSupplement.value supplement's value}."
    },
    {
      "name": "shoppings_sellers_sales_units_stocks_supplements_index",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Belonged sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "unitId": {
            "type": "string",
            "description": " Belonged unit's {@link IShoppingSaleUnit.id }\n\n\n@format uuid"
          },
          "stockId": {
            "type": "string",
            "description": " Target stock's {@link IShoppingSaleUnitStock.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "sort": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "-created_at",
                    "+created_at"
                  ]
                },
                "nullable": true,
                "description": "Sortable columns."
              },
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Request info of pagination, searching and sorting\n\n------------------------------\n\nDescription of the current {@link IShoppingSaleUnitStockSupplement.IRequest} type:\n\n> Request information of the stock supplement list.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSaleUnitStockSupplement} type:\n\n> Supplementation of inventory quantity of stock.\n> \n> You know what? If a {@link IShoppingSaleUnitStock stock} has been sold over\n> its {@link IShoppingSaleUnitStock.ICreate.quantity initial inventory quantity},\n> the stock can't be sold anymore, because of out of stock. In that case, how the\n> {@link IShoppingSeller} should do?\n> \n> When the sotck is sold out, seller can supplement the inventory record by\n> registering this `IShoppingSaleUnitStockSupplement` record. Right, this\n> `IShoppingSaleUnitStockSupplement` is an entity that embodies the\n> supplementation of the inventory quantity of the belonged stock."
          }
        },
        "required": [
          "saleId",
          "unitId",
          "stockId",
          "body"
        ]
      },
      "description": "List up every supplements.\n\nList up every {@link IShoppingSaleUnitStockSupplement supplement histories}\nof a specific {@link IShoppingSaleUnitStock stock}.\n\nIf you want, you can limit the result by configuring\n{@link IShoppingSaleUnitStockSupplement.IRequest.search search condition} in\nthe request body. Also, it is possible to customize sequence order of\nrecords by configuring {@link IShoppingSaleUnitStockSupplement.IRequest.sort}\nproperty."
    },
    {
      "name": "shoppings_sellers_sales_units_stocks_supplements_update",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Belonged sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "unitId": {
            "type": "string",
            "description": " Belonged unit's {@link IShoppingSaleUnit.id }\n\n\n@format uuid"
          },
          "stockId": {
            "type": "string",
            "description": " Target stock's {@link IShoppingSaleUnitStock.id }\n\n\n@format uuid"
          },
          "id": {
            "type": "string",
            "description": " Target supplement's {@link IShoppingSaleUnitStockSupplement.id }\n\n\n@format uuid"
          },
          "body": {
            "type": "object",
            "properties": {
              "value": {
                "type": "integer",
                "description": "Supplemented quantity.\n\n\n@minimum 0"
              }
            },
            "required": [
              "value"
            ],
            "description": "Update info (quantity) of the supplement\n\n------------------------------\n\nDescription of the current {@link IShoppingSaleUnitStockSupplement.ICreate} type:\n\n> Creation information of the supplement.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSaleUnitStockSupplement} type:\n\n> Supplementation of inventory quantity of stock.\n> \n> You know what? If a {@link IShoppingSaleUnitStock stock} has been sold over\n> its {@link IShoppingSaleUnitStock.ICreate.quantity initial inventory quantity},\n> the stock can't be sold anymore, because of out of stock. In that case, how the\n> {@link IShoppingSeller} should do?\n> \n> When the sotck is sold out, seller can supplement the inventory record by\n> registering this `IShoppingSaleUnitStockSupplement` record. Right, this\n> `IShoppingSaleUnitStockSupplement` is an entity that embodies the\n> supplementation of the inventory quantity of the belonged stock."
          }
        },
        "required": [
          "saleId",
          "unitId",
          "stockId",
          "id",
          "body"
        ]
      },
      "description": "Update a supplement.\n\nUpdate quantity value of a {@link IShoppingSaleUnitStockSupplement supplement}\nof a specific {@link IShoppingSaleUnitStock stock}.\n\nTherefore, {@link IShoppingSaleUnitStockInventory.income inventory} of the\ntarget stock will be changed by the\n{@link IShoppingSaleUnitStockSupplement.value supplement's value}."
    },
    {
      "name": "shoppings_sellers_sales_units_stocks_supplements_erase",
      "parameters": {
        "type": "object",
        "properties": {
          "saleId": {
            "type": "string",
            "description": " Belonged sale's {@link IShoppingSale.id }\n\n\n@format uuid"
          },
          "unitId": {
            "type": "string",
            "description": " Belonged unit's {@link IShoppingSaleUnit.id }\n\n\n@format uuid"
          },
          "stockId": {
            "type": "string",
            "description": " Target stock's {@link IShoppingSaleUnitStock.id }\n\n\n@format uuid"
          },
          "id": {
            "type": "string",
            "description": " Target supplement's {@link IShoppingSaleUnitStockSupplement.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "saleId",
          "unitId",
          "stockId",
          "id"
        ]
      },
      "description": "Erase a supplement.\n\nErase a {@link IShoppingSaleUnitStockSupplement supplement} of a specific\n{@link IShoppingSaleUnitStock stock}.\n\nTherefore, {@link IShoppingSaleUnitStockInventory.income inventory} of the\ntarget stock will be decreased by the\n{@link IShoppingSaleUnitStockSupplement.value supplement's value}."
    },
    {
      "name": "shoppings_sellers_systematic_channels_categories_index",
      "parameters": {
        "type": "object",
        "properties": {
          "channelCode": {
            "type": "string",
            "description": " Belonged channel's {@link IShoppingChannel.code }"
          }
        },
        "required": [
          "channelCode"
        ]
      },
      "description": "List up every categories with children records.\n\nList up every {@link IShoppingChannelCategory.IHierarchical categories}\nof a {@link IShoppingChannel channel} with pagination. Returned categories\ncontain children categories, too.\n\nIf you want, you can limit the result by configuring\n{@link IShoppingChannelCategory.IRequest.search search condition} in the\nrequest body. Also, it is possible to customize sequence order of records\nby configuring {@link IShoppingChannelCategory.IRequest.sort sort condition}."
    },
    {
      "name": "shoppings_sellers_systematic_channels_categories_at",
      "parameters": {
        "type": "object",
        "properties": {
          "channelCode": {
            "type": "string",
            "description": " Belonged channel's {@link IShoppingChannel.code }"
          },
          "id": {
            "type": "string",
            "description": " Target category's {@link IShoppingChannelCategory.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "channelCode",
          "id"
        ]
      },
      "description": "Get a category info.\n\nGet a detailed {@link IShoppingChannelCategory category} information.\n\nReturned category contains hierarchical children categories, and also\ncontains the recursive parent categories, too."
    },
    {
      "name": "shoppings_sellers_systematic_channels_categories_invert",
      "parameters": {
        "type": "object",
        "properties": {
          "channelCode": {
            "type": "string",
            "description": " Belonged channel's {@link IShoppingChannel.code }"
          },
          "id": {
            "type": "string",
            "description": " Target category's {@link IShoppingChannelCategory.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "channelCode",
          "id"
        ]
      },
      "description": "Get a category info of inverted.\n\nGet a inverted {@link IShoppingChannelCategory.IInvert category} information.\n\nReturned category contains the recursive parent categories, but not contains\nthe hierarchical children categories."
    },
    {
      "name": "shoppings_sellers_systematic_channels_index",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "search": {
                "type": "object",
                "properties": {
                  "code": {
                    "type": "string",
                    "nullable": true
                  },
                  "name": {
                    "type": "string",
                    "nullable": true
                  }
                },
                "required": [],
                "nullable": true
              },
              "sort": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "-channel.code",
                    "-channel.name",
                    "-channel.created_at",
                    "+channel.code",
                    "+channel.name",
                    "+channel.created_at"
                  ]
                },
                "nullable": true
              },
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Request info of pagination, searching and sorting\n\n------------------------------\n\nDescription of the current {@link IShoppingChannel.IRequest} type:\n\n> Request of the channels with pagination and searching/sorting options.\n\n------------------------------\n\nDescription of the parent {@link IShoppingChannel} type:\n\n> Channel information.\n> \n> `IShoppingChannel` is a concept that shapes the distribution channel in the\n> market. Therefore, the difference in the channel in this e-commerce system\n> means that it is another site or application.\n> \n> By the way, if your shopping mall system requires only one channel, then\n> just use only one. This concept is designed to be expandable in the future."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "List up every channels.\n\nList up every {@link IShoppingChannel channels} with pagination.\n\nIf you want, you can limit the result by configuring\n{@link IShoppingChannel.IRequest.search search condition} in the request\nbody. Also, it is possible to customize sequence order of records by\nconfiguring {@link IShoppingChannel.IRequest.sort sort condition}."
    },
    {
      "name": "shoppings_sellers_systematic_channels_hierarchical",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "search": {
                "type": "object",
                "properties": {
                  "code": {
                    "type": "string",
                    "nullable": true
                  },
                  "name": {
                    "type": "string",
                    "nullable": true
                  }
                },
                "required": [],
                "nullable": true
              },
              "sort": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "-channel.code",
                    "-channel.name",
                    "-channel.created_at",
                    "+channel.code",
                    "+channel.name",
                    "+channel.created_at"
                  ]
                },
                "nullable": true
              },
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Request info of pagination, searching and sorting\n\n------------------------------\n\nDescription of the current {@link IShoppingChannel.IRequest} type:\n\n> Request of the channels with pagination and searching/sorting options.\n\n------------------------------\n\nDescription of the parent {@link IShoppingChannel} type:\n\n> Channel information.\n> \n> `IShoppingChannel` is a concept that shapes the distribution channel in the\n> market. Therefore, the difference in the channel in this e-commerce system\n> means that it is another site or application.\n> \n> By the way, if your shopping mall system requires only one channel, then\n> just use only one. This concept is designed to be expandable in the future."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "List up every channels with nested categories.\n\nList up every {@link IShoppingChannel.IHierarchical channels} with\n{@link IPage pagination}. Returned channels contain nested hierarchical\n{@link IShoppingChannelCategory.IHierarchical categories}.\n\nIf you want, you can limit the result by configuring\n{@link IShoppingChannel.IRequest.search search condition} in the request\nbody. Also, it is possible to customize sequence order of records by\nconfiguring {@link IShoppingChannel.IRequest.sort sort condition}."
    },
    {
      "name": "shoppings_sellers_systematic_channels_at",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target channel's {@link IShoppingChannel.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Get a channel info.\n\nGet a detailed {@link IShoppingChannel.IHierarchical channel} information.\n\nReturned channel instance also contains the nested\n{@link IShoppingChannelCategory.IHierarchical hierarchical category}\ninformation."
    },
    {
      "name": "shoppings_sellers_systematic_channels_get",
      "parameters": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "description": " Target channel's {@link IShoppingChannel.code }"
          }
        },
        "required": [
          "code"
        ]
      },
      "description": "Get a channel info by its code.\n\nGet a detailed {@link IShoppingChannel.IHierarchical channel} information\nby its code.\n\nReturned channel instance also contains the nested\n{@link IShoppingChannelCategory.IHierarchical hierarchical category}\ninformation."
    },
    {
      "name": "shoppings_sellers_systematic_sections_index",
      "parameters": {
        "type": "object",
        "properties": {
          "body": {
            "type": "object",
            "properties": {
              "search": {
                "type": "object",
                "properties": {
                  "code": {
                    "type": "string",
                    "nullable": true
                  },
                  "name": {
                    "type": "string",
                    "nullable": true
                  }
                },
                "required": [],
                "nullable": true
              },
              "sort": {
                "type": "array",
                "items": {
                  "type": "string",
                  "enum": [
                    "-section.code",
                    "-section.name",
                    "-section.created_at",
                    "+section.code",
                    "+section.name",
                    "+section.created_at"
                  ]
                },
                "nullable": true
              },
              "page": {
                "type": "integer",
                "nullable": true,
                "description": "Page number.\n\n\n@minimum 0"
              },
              "limit": {
                "type": "integer",
                "nullable": true,
                "description": "Limitation of records per a page.\n\n\n@minimum 0"
              }
            },
            "required": [],
            "description": "Request info of pagination, searching and sorting\n\n------------------------------\n\nDescription of the current {@link IShoppingSection.IRequest} type:\n\n> Request of the sections with pagination and searching/sorting options.\n\n------------------------------\n\nDescription of the parent {@link IShoppingSection} type:\n\n> Section information.\n> \n> `IShoppingSection` is a concept that refers to the spatial information of\n> the market.\n> \n> If we compare the section mentioned here to the offline market, it means a\n> spatially separated area within the store, such as the \"fruit corner\" or\n> \"butcher corner\". Therefore, in the {@link IShoppingSale sale} entity, it is\n> not possible to classify multiple sections simultaneously, but only one section\n> can be classified.\n> \n> By the way, if your shopping mall system requires only one section, then just\n> use only one. This concept is designed to be expandable in the future."
          }
        },
        "required": [
          "body"
        ]
      },
      "description": "List up every sections.\n\nList up every {@link IShoppingSection sections} with pagination.\n\nIf you want, you can limit the result by configuring\n{@link IShoppingSection.IRequest.search search condition} in the request\nbody. Also, it is possible to customize sequence order of records by\nconfiguring {@link IShoppingSection.IRequest.sort sort condition}."
    },
    {
      "name": "shoppings_sellers_systematic_sections_at",
      "parameters": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": " Target section's {@link IShoppingSection.id }\n\n\n@format uuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "description": "Get a section info.\n\nGet a detailed {@link IShoppingSection section} information."
    },
    {
      "name": "shoppings_sellers_systematic_sections_get",
      "parameters": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "description": " Target section's {@link IShoppingSection.code }"
          }
        },
        "required": [
          "code"
        ]
      },
      "description": "Get a section info by its code.\n\nGet a detailed {@link IShoppingSection section} information by its code."
    }
  ],
  "options": {
    "recursive": 3,
    "maxLength": null
  },
  "errors": []
}